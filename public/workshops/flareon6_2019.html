
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Flare-on 6 2019 Writeups</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="../pkg/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
  <script src="../gif/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../gif/gif-player.es5.js" defer async></script>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="flareon6_2019"
                  title="Flare-on 6 2019 Writeups"
                  environment="web"
                  feedback-link="">

      <google-codelab-step label="Introduction" duration="0">
        <p>Every year the Flare team puts on a reverse engineering CTF called the <a href="http://www.flare-on.com" target="_blank">Flare-On Challenge</a>. These challenges are loosely based off malware and techniques that are seen in malware. The nice thing about these challenges is that it helps folks like me to keep my skills sharp. Majority of these challenges are heavily windows based, so unless you have a Windows VM, debugging can be tough. Usually most can be solved with just using IDA pro or Ghidra without needing to debug anything.</p>
<p>All flags are suffixed with &#34;@flare-on.com&#34; which is very helpful in finding flags are encrypted.</p>
<p>In this walk-through I will assume that the first 4 challenges are for new reverse engineers and will be over-explaining a bit. The rest should be more high level for keeping the length down.</p>
<h2 is-upgraded>Summary of Challenges</h2>
<ol type="1" start="1">
<li><strong>Memecat Battlestation</strong> - A Simple Windows .NET Gui program </li>
<li><strong>Overlong </strong>- Simple Windows program that requires an easy patch</li>
<li><strong>Flarebear </strong>- A cute android app that is a Tomagotchi pet</li>
<li><strong>Dnschess </strong>- An Linux ELF program that uses DNS requests to acquire moves on a chess board.</li>
<li><strong>Demo </strong>- A Windows program that uses DirectX 9 to control 3D sprites.</li>
<li><strong>Bmphide </strong>- A .NET program that uses Steganography to hide multiple images.</li>
<li><strong>Wopr </strong>- A Windows Pyinstaller exe that uses a math problem to get launch codes.</li>
<li><strong>Snake </strong>- An old NES game that has a simple solution to win the game.</li>
<li><strong>Reloadered </strong>- a broken header Windows exe that has some Rick-Rolling fun.</li>
<li><strong>Mugatu </strong>- A Windows exe based on ransomware.</li>
<li><strong>Vv_max </strong>- Another esoteric language Windows x64 exe that uses AVX2 instructions.</li>
<li><strong>Help </strong>- A Windows memory dump that contains a few kernel drivers and userland Dlls. Looks like a plugin style RAT.</li>
</ol>


      </google-codelab-step>

      <google-codelab-step label="Challenge 1 - Memecat Battlestation" duration="0">
        <p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/abc1a65e921b63a8.png"></p>
<h2 is-upgraded>Summary</h2>
<p>This is a simple .NET GUI program that uses a simple byte XOR based on the modulo length of the string created by the name of the weapons you choose.</p>
<h2 is-upgraded>Tools to use</h2>
<ul>
<li><a href="https://github.com/0xd4d/dnSpy/releases" target="_blank">Dnspy </a>or ILSpy</li>
<li><a href="https://github.com/hasherezade/pe-bear-releases/releases" target="_blank">PE Bear</a> (alternatives: CFF explorer, PE studio)</li>
</ul>
<h2 is-upgraded>Challenge Text</h2>
<pre><code>Memecat Battlestation [Shareware Demo Edition]
Welcome to the Sixth Flare-On Challenge!
The 7zip password is: flare
This is a simple game. Reverse engineer it to figure out what &#34;weapon codes&#34; you need to enter to defeat each of the two enemies and the victory screen will reveal the flag. Enter the flag here on this site to score and move on to the next level.
This challenge is written in .NET. If you don&#39;t already have a favorite .NET reverse engineering tool I recommend dnSpy</code></pre>
<h2 is-upgraded>Getting Started</h2>
<p>With any new binary you receive be sure triage and handle with care. While these CTFs are generally good natured, never trust any binary and examine in a Virtual Machine. Use a hex editor, binwalk, or the <em>file</em> command on your *nix shell to determine the file type. Use PE Bear, CFF explorer, or PE studio to help you identify what kind of PE binary it could be.</p>
<h2 is-upgraded>Program</h2>
<p>After opening in Dnspy you can see that there are 3 forms to actually care about. If you haven&#39;t made a GUI .NET form program before, I highly recommend coding up one yourself. To put it in plain words, each form class acts like a scene in the GUI which means each class has several visual properties that reference objects in the resources (MemcatBattelstation.Properties). When working with malware, the resources of a .NET program is a great place to start looking for clues.</p>
<h2 is-upgraded>Victory Form</h2>
<p>In the main program, there are references to the form classes: stage1, stage2, and VictoryForm. The constructor for the victory form is taking in a string concatenated from strings returned from stage1 and stage2. When the VictoryForm is constructed it loads the encoded flag as a byte array of 31 integers. The constructor string was used to decode the encoded byte array using a simple XOR routine. </p>
<pre><code>Application.Run(new VictoryForm
{
        Arsenal = string.Join(&#34;,&#34;, new string[]
        {
                stage2Form.WeaponCode,
                stage1Form.WeaponCode
        }),
        Location = stage2Form.Location
});</code></pre>
<h2 is-upgraded>Stage 1</h2>
<p>Since this is a game that requires you to enter in a weapon name, the next step is finding out what those weapon names are. The form class should have an event function associated with the button click. This takes in a string which becomes very obvious with the IF statement.</p>
<p>So at this point, the Stage 1 form is looking for a string RAINBOW as the weapon name. There is a dank animation afterwards.</p>
<p class="image-container"><img style="width: 447.50px" src="../flareon6_2019/img/94facda6220dcc64.png"></p>
<h2 is-upgraded>Stage 2</h2>
<p>The second stage becomes a little bit tricky, but like I said the clues are in the resource section. You can use deductive reasoning to guess which image objects haven&#39;t been referenced yet:</p>
<ul>
<li>Rainbowlaser (Stage 1)</li>
<li>Bagels</li>
</ul>
<p>Knowing that the answer is using both stage1 and stage2 weapon code combined we already know part of the key. Can also assume that the end of the 31 byte array ends with &#34;@flare-on.com&#34;. There is also a function call isValidWeaponCode that verifies if the string matches the hard coded sequence shown below. The isValidWeaponCode function pretty much takes out the guesswork.</p>
<pre><code>private bool isValidWeaponCode(string s)
{
        char[] array = s.ToCharArray();
        int length = s.Length;
        for (int i = 0; i &lt; length; i++)
        {
                char[] array2 = array;
                int num = i;
                array2[num] ^= &#39;A&#39;;
        }
        return array.SequenceEqual(new char[]
        {
                &#39;\u0003&#39;,
                &#39; &#39;,
                &#39;&amp;&#39;,
                &#39;$&#39;,
                &#39;-&#39;,
                &#39;\u001e&#39;,
                &#39;\u0002&#39;,
                &#39; &#39;,
                &#39;/&#39;,
                &#39;/&#39;,
                &#39;.&#39;,
                &#39;/&#39;
        });
}</code></pre>
<p>In the end you are left with:</p>
<pre><code>RAINBOWBagel_Cannon</code></pre>
<p>It&#39;s all downhill from that point. The following function is used to decode the integer array.</p>
<pre><code>byte[] bytes = Encoding.UTF8.GetBytes(this.Arsenal);
for (int i = 0; i &lt; array.Length; i++)
{
        byte[] array2 = array;
        int num = i;
        array2[num] ^= bytes[i % bytes.Length];
}
this.flagLabel.Text = Encoding.UTF8.GetString(array);</code></pre>
<p>And then you get another dank animation.</p>
<p class="image-container"><img style="width: 428.91px" src="../flareon6_2019/img/48f8918515f4d42.png"></p>
<p>The flag will be revealed after that.</p>
<p class="image-container"><img style="width: 427.50px" src="../flareon6_2019/img/2187f8c5b893d169.png"></p>


      </google-codelab-step>

      <google-codelab-step label="Challenge 2 - Overlong" duration="0">
        <h2 is-upgraded>Summary</h2>
<p>This is a simple Windows x32 PE program that decrypts the flag within a loop that never triggers. You will need to either patch the program or modify the branch flags in the debugger to advance.</p>
<h2 is-upgraded>Tools to use</h2>
<ul>
<li><a href="https://github.com/hasherezade/pe-bear-releases/releases" target="_blank">PE Bear</a> (alternatives: CFF explorer, PE studio)</li>
<li>IDA (alternatives: Ghidra, Radare2)</li>
<li><a href="https://x64dbg.com/" target="_blank">X32dbg</a> (alternatives: Ollydbg, Windbg, Immunity)</li>
</ul>
<h2 is-upgraded>Challenge Text</h2>
<pre><code>Overlong
1
The secret of this next challenge is cleverly hidden. However, with the right approach, finding the solution will not take an overlong amount of time.
*The 7zip password is: flare</code></pre>
<h2 is-upgraded>Identifying the problem</h2>
<p>In a disassembler, offset 0x117E is where the function decides to loop through the encoded text. Using the graph mode in your disassembler will help you see the loop designated by the blue arrow lines. The branch statement is where you will want to modify in the debugger.</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/e66ecb36b7a11c11.png"></p>
<h2 is-upgraded>Modifying the Control Flow</h2>
<p>In x32dbg, you can patch instructions. In this case, I did not want to take the branch jump so it was easier just to &#34;<a href="https://en.wikipedia.org/wiki/NOP_(code)" target="_blank">nop</a>&#34; out the instruction altogether. Be sure to fill the rest of the bytes with nops.</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/b45f93631ea34f56.png"></p>
<p>Typically in byte arrays that are being processed, the byte needs to be moved from a register to a memory address. It&#39;s easier to find a <code>mov [address], register</code> instruction (intel syntax) as a quicker way to find the destination.</p>
<p>In x32dbg, if you right click on the destination address within the instruction and you can view that address in the dump window as seen below. After you have patched the instructions, you can continue to run the program and it will reveal the flag.</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/5d3c7034fb3a1c1b.png"></p>


      </google-codelab-step>

      <google-codelab-step label="Challenge 3 - Flarebear" duration="0">
        <p class="image-container"><img style="width: 457.54px" src="../flareon6_2019/img/c92718686f08545a.png"></p>
<h2 is-upgraded>Summary</h2>
<p>This is a Tamagotchi themed android apk that uses simple math to decrypt the flag. The math product is calculated by the inputs of playing, feeding, and cleaning poop.</p>
<h2 is-upgraded>Tools to use</h2>
<ul>
<li><a href="https://ibotpeaches.github.io/Apktool/" target="_blank">Apktool</a></li>
<li><a href="https://github.com/pxb1988/dex2jar/releases" target="_blank">dex2jar</a></li>
<li><a href="https://github.com/java-decompiler/jd-gui" target="_blank">Jd-gui</a> (alternatives: <a href="https://www.pnfsoftware.com/" target="_blank">JEB Decompiler</a>)</li>
<li><a href="https://developer.android.com/studio" target="_blank">Android studio</a> (mainly to use the emulators)</li>
</ul>
<h2 is-upgraded>Challenge Text</h2>
<pre><code>Flarebear
1
We at Flare have created our own Tamagotchi pet, the flarebear. He is very fussy. Keep him alive and happy and he will give you the flag.
7Zip password: flare</code></pre>
<h2 is-upgraded>Deconstructing an APK</h2>
<p>The apktool does a good job at getting you the file you need the most which is the classes.dex file which is a Dalvik executable. The command below should do the trick.</p>
<pre><code>apktool d flarebear.apk</code></pre>
<p>Next you will need to convert the dex file into a jar to that you can decompile with a java decompiler tool. Using dex2jar should help with that. </p>
<pre><code>d2j-dex2jar.sh -f ~/path/to/classes.dex</code></pre>
<p>Once you have the jar file in my case classes-dex2jar.jar, you can use the tool jd-gui to decompile the jar.</p>
<pre><code>java -j jd-gui.jar</code></pre>
<p>Finally download an emulator from Android studio, using Tools-&gt;SDK Manager-&gt;Android SDK-&gt;SDK Tools Tab-&gt;Android Emulator. Under Tools-&gt;AVD Manager is where you can manage all the android virtual machines for debugging the APK. You can open the original APK in Android studio and debug with the emulator/AVD build you downloaded. At this point you have the java classes loaded in jd-gui and the flarebear.apk running in the emulator from android studio.</p>
<h2 is-upgraded>Identifying the Problem</h2>
<p>Android malware can sometimes hide binary data in the APK &#34;raw&#34; resources. In the raw folder from the apktool dump, files named &#34;ecstatic&#34; and &#34;estatic2&#34; are highly suspicious. It will be useful to trace these filenames in the code: ecstatic -&gt; openRawResource -&gt;danceWithFlag-&gt;isEcstatic-&gt;setMood.</p>
<p>In debugging in android studio has a window you can view the values of the password for the decrypt function. You&#39;ll notice that the password is built from the string created from the combination of inputs.</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/6b51bcd2f22c535.png"></p>
<p>The next step is to determine how the input relates to the functions. In FlarebearActivity.java, there are isHappy and IsEstatic functions that precede the decryption of final flag image in function danceWithFlag.</p>
<pre><code>public final void setMood() {
    if (isHappy()) {
      ((ImageView)_$_findCachedViewById(R.id.flareBearImageView)).setTag(&#34;happy&#34;);
      if (isEcstatic()) {
        danceWithFlag();
        return;
      }
    } else {
      ((ImageView)_$_findCachedViewById(R.id.flareBearImageView)).setTag(&#34;sad&#34;);
    }
  }</code></pre>
<p>The actions play, feed, and poop accumulate mass, happy, and clean values. In the function <code>isEcstatic</code> these values tested against hard coded integers. Figuring out the combination becomes a simple math problem that you can do by hand.</p>
<pre><code>public final boolean isEcstatic() {
    byte b = 0;
    int i = getState(&#34;mass&#34;, 0);
    int j = getState(&#34;happy&#34;, 0);
    int k = getState(&#34;clean&#34;, 0);
    int m = b;
    if (i == 72) {
      m = b;
      if (j == 30) {
        m = b;
        if (k == 0)
          m = 1;
      }
    }
    return m;
  }</code></pre>
<p>Using the emulator you can plug in 8 feeds, 4 plays, 2 cleans and it will decrypt an image from the resources to reveal the flag.</p>
<p class="image-container"><img style="width: 343.99px" src="../flareon6_2019/img/ba2ed5b09c24fdfc.png"></p>


      </google-codelab-step>

      <google-codelab-step label="Challenge 4 - Dnschess" duration="0">
        <p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/d7f15c5a9d75902.png"></p>
<h2 is-upgraded>Summary</h2>
<p>This challenge has 2 x64 ELF binaries that utilizes the DNS requests as inputs for determining the next move on a chess board.</p>
<h2 is-upgraded>Tools to use</h2>
<ul>
<li>IDA</li>
<li>Linux x64 VM</li>
<li>GDB</li>
<li>Wireshark and/or Tshark</li>
</ul>
<h2 is-upgraded>Challenge Text</h2>
<pre><code>Dnschess
1
Some suspicious network traffic led us to this unauthorized chess program running on an Ubuntu desktop. This appears to be the work of cyberspace computer hackers. You&#39;ll need to make the right moves to solve this one. Good luck!
7Zip password: flare</code></pre>
<h2 is-upgraded>Identifying the Problem</h2>
<p>Some malware and RAT kits can use DNS requests as a form of communication to the command and control node. ChessUI binary serves just as the UI for the chessboard while ChessAI.so is the library that calculates the next chess moves based off of the DNS responses. The Flare team likes to take you down rabbit holes when the solution is very simple.</p>
<p>In ChessAI.so the function <code>getNextMove</code> takes the values from the DNS requests and converts them for positions on the chessboard. The if statement <code>if ( *v10 != 127 || v10[3] &amp; 1 || a1 != (v10[2] &amp; 0xF))</code>was the most obvious clue in that it is looking for 127 like in 127.0.0.1. So I just need to make sure when I replay packets that the IP addresses contain these values. Easy peasy.</p>
<p class="image-container"><img style="width: 573.00px" src="../flareon6_2019/img/7b2f68f414fc700c.png"></p>
<p>I was too lazy to stand up a DNS tool to replay the pcap so instead I just changed my /etc/hosts file on my ubuntu vm to match. I used tshark to grep all the IP addresses and domain names.</p>
<pre><code>tshark -r capture.pcap -T fields -e dns.a -e dns.qry.name -2 -R &#34;dns.flags.response eq 1&#34;</code></pre>
<p>My /etc/hosts file:</p>
<pre><code>127.150.96.223        rook-c3-c6.game-of-thrones.flare-on.com
127.252.212.90        knight-g1-f3.game-of-thrones.flare-on.com
127.215.177.38        pawn-c2-c4.game-of-thrones.flare-on.com
127.118.118.207        knight-c7-d5.game-of-thrones.flare-on.com
127.89.38.84        bishop-f1-e2.game-of-thrones.flare-on.com
127.109.155.97        rook-a1-g1.game-of-thrones.flare-on.com
127.217.37.102        bishop-c1-f4.game-of-thrones.flare-on.com
127.49.59.14        bishop-c6-a8.game-of-thrones.flare-on.com
127.182.147.24        pawn-e2-e4.game-of-thrones.flare-on.com
127.0.143.11        king-g1-h1.game-of-thrones.flare-on.com
127.227.42.139        knight-g1-h3.game-of-thrones.flare-on.com
127.101.64.243        king-e5-f5.game-of-thrones.flare-on.com
127.201.85.103        queen-d1-f3.game-of-thrones.flare-on.com
127.200.76.108        pawn-e5-e6.game-of-thrones.flare-on.com
127.50.67.23        king-c4-b3.game-of-thrones.flare-on.com
127.157.96.119        king-c1-b1.game-of-thrones.flare-on.com
127.99.253.122        queen-d1-h5.game-of-thrones.flare-on.com
127.25.74.92        bishop-f3-c6.game-of-thrones.flare-on.com
127.168.171.31        knight-d2-c4.game-of-thrones.flare-on.com
127.148.37.223        pawn-c6-c7.game-of-thrones.flare-on.com
127.108.24.10        bishop-f4-g3.game-of-thrones.flare-on.com
127.37.251.13        rook-d3-e3.game-of-thrones.flare-on.com
127.34.217.88        pawn-e4-e5.game-of-thrones.flare-on.com
127.57.238.51        queen-a8-g2.game-of-thrones.flare-on.com
127.196.103.147        queen-a3-b4.game-of-thrones.flare-on.com
127.141.14.174        queen-h5-f7.game-of-thrones.flare-on.com
127.238.7.163        pawn-h4-h5.game-of-thrones.flare-on.com
127.230.231.104        bishop-e2-f3.game-of-thrones.flare-on.com
127.55.220.79        pawn-g2-g3.game-of-thrones.flare-on.com
127.184.171.45        knight-h8-g6.game-of-thrones.flare-on.com
127.196.146.199        bishop-b3-f7.game-of-thrones.flare-on.com
127.191.78.251        queen-d1-d6.game-of-thrones.flare-on.com
127.159.162.42        knight-b1-c3.game-of-thrones.flare-on.com
127.184.48.79        bishop-f1-d3.game-of-thrones.flare-on.com
127.127.29.123        rook-b4-h4.game-of-thrones.flare-on.com
127.191.34.35        bishop-c1-a3.game-of-thrones.flare-on.com
127.5.22.189        bishop-e8-b5.game-of-thrones.flare-on.com
127.233.141.55        rook-f2-f3.game-of-thrones.flare-on.com
127.55.250.81        pawn-a2-a4.game-of-thrones.flare-on.com
127.53.176.56        pawn-d2-d4.game-of-thrones.flare-on.com</code></pre>
<p>The next easy step was to just take all the values from the DNS request and plug them into the gameboard. As an example the DNS request <code>rook-c3-c6.game-of-thrones.flare-on.com</code> is to move rook from position c3 to c6 on the chess board. </p>
<p>Simple right? But wait there&#39;s more!</p>
<p>Turns out that the order of the DNS request are not sequential. The other parts of the IP address dedupes and numbers the order of the requests: <code>v10[3] &amp; 1</code> and <code>a1 != (v10[2] &amp; 0xF).</code></p>
<pre><code>4 0 252.212.90
1 0 215.177.38
6 0 89.38.84
5 0 217.37.102
b 0 49.59.14
3 0 182.147.24
c 0 200.76.108
d 0 99.253.122
a 0 25.74.92
8 0 108.24.10
9 0 34.217.88
e 0 141.14.174
7 0 230.231.104
2 0 159.162.42
0 0 53.176.56</code></pre>
<p>Just go through all the positions after that and it will reveal the flag once you have one the game.</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/73d5cde27ae858e7.png"></p>


      </google-codelab-step>

      <google-codelab-step label="Challenge 5 - Demo" duration="0">
        <p class="image-container"><img style="width: 547.50px" src="../flareon6_2019/img/b2b622ce5b64c422.gif"></p>
<h2 is-upgraded>Summary</h2>
<p>This is an x32 PE executable with a shrunken header that uses the DirectX 9 library to handle 3D sprites and their translations on a plane.</p>
<h2 is-upgraded>Tools to use</h2>
<ul>
<li>IDA</li>
<li>PE Bear or CFF explorer</li>
<li>x32dbg</li>
<li><a href="https://www.microsoft.com/en-us/download/confirmation.aspx?id=35" target="_blank">d3d9.dll</a></li>
<li><a href="https://www.microsoft.com/en-US/Download/confirmation.aspx?id=8109" target="_blank">d3dx9_43.dll</a></li>
</ul>
<h2 is-upgraded>Challenge Text</h2>
<pre><code>demo
1
Someone on the Flare team tried to impress us with their demoscene skills. It seems blank. See if you can figure it out or maybe we will have to fire them. No pressure.
7Zip password: flare ** You will need DirectX 9</code></pre>
<h2 is-upgraded>Shrunken PE Header</h2>
<p>Always use a PE header parser like CFF explorer or PE Bear to verify the that the header looks correct. I had found that this header seemed to be smaller than normal and lacked a section table. Here is a link that I found useful: <a href="https://www.bigmessowires.com/2015/10/08/a-handmade-executable-file/" target="_blank">https://www.bigmessowires.com/2015/10/08/a-handmade-executable-file/</a></p>
<p>DOS Header  PE Header Optional Header Overlap Optional Header Code EntryPoint</p>
<pre><code>00000000: 4d5a 3231 5045 0000 4c01 0000 01db 617f  MZ21PE..L.....a.
00000010: 10d0 1773 7547 ebf9 0800 0200 0b01 11c9  ...suG..........
00000020: 4585 c079 1f01 d350 f7e2 903d 5c00 0000  E..y...P...=\...
00000030: f7f3 39c1 19db eb48 0000 4000 0400 0000  ..9....H..@.....
00000040: 0400 0000 0fa3 2d6a 0140 008d 0400 ebce  ......-j.@......
00000050: 0000 0000 ebb6 431f 4000 0000 5331 edbb  ......C.@...S1..
00000060: 0200 0000 90be 4401 4000 6a01 58bf 0000  ......D.@.j.X...
00000070: 4200 b100 9057 eb12 0000 0000 0000 0000  B....W..........
00000080: 5a72 0792 29d1 0400 29d0 60ad 01f8 742c  Zr..)...).`...t,
00000090: 6a0a 5a89 1454 8954 2410 ad31 ed4d 4501  j.Z..T.T$..1.ME.</code></pre>
<h2 is-upgraded>Identifying the Problem</h2>
<p>I think I spent majority of this challenge reading up on DirectX 3D programs. I didn&#39;t even know what a &#34;demo&#34; was until I had to find the term in gaming pop culture articles. The best way I can describe it is like a graphic designer showing off their portfolio pieces. The best resource I could find on was on <a href="https://github.com/GameHackingBook/GameHackingCode/blob/master/Chapter8_Direct3DApplication/main.cpp" target="_blank">Game Hacking from Nick Cano</a>. This resource helped explained how to manipulate 3D meshes and 3D Matrix translations. </p>
<p>I found that there were 2 3D meshes that were being placed on the plane. The first mesh being the Flare logo and the unknown second mesh. <code>D3DXMatrixTranslation</code> function controlled how those meshes were displayed. If you ever worked with Blender or Autodesk Maya before you know that there are 3 positions: X, Y, and Z. </p>
<pre><code>D3DXMATRIX* D3DXMatrixTranslation(
  _Inout_ D3DXMATRIX *pOut,
  _In_    FLOAT      x,
  _In_    FLOAT      y,
  _In_    FLOAT      z
);</code></pre>
<p>Remember that arguments are pushed onto the stack backwards starting with Z, Y, X. The Z position was grossly out of proportion at 0x3FAAAAAB. So this position is way off the camera view. If you patched the instruction or changed the value on the stack to 0, it will render the second mesh will be displayed in front of the Flare logo.</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/797351bf80929ceb.png"></p>
<p>Here is the image of the second mesh with a new Z offset:</p>
<p class="image-container"><img style="width: 539.33px" src="../flareon6_2019/img/46eef87d7ccf8c75.png"></p>


      </google-codelab-step>

      <google-codelab-step label="Challenge 6 - Bmphide" duration="0">
        <p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/c54853bdd1d7f429.png"></p>
<h2 is-upgraded>Summary</h2>
<p>This is a .NET executable that uses the most significant bit steganography to hide an image within another image. This challenge also uses IL code modification to edit values of function offsets and immediate values.</p>
<h2 is-upgraded>Tools to use</h2>
<ul>
<li><a href="https://github.com/0xd4d/dnSpy/releases" target="_blank">Dnspy </a>or ILSpy</li>
<li>Visual Studio for .NET (optional)</li>
</ul>
<h2 is-upgraded>Challenge Text</h2>
<pre><code>bmphide
1
Tyler Dean hiked up Mt. Elbert (Colorado&#39;s tallest mountain) at 2am to capture this picture at the perfect time. Never skip leg day. We found this picture and executable on a thumb drive he left at the trail head. Can he be trusted?
7Zip password: flare</code></pre>
<h2 is-upgraded>A little bit about .NET</h2>
<p>Like any other higher level language, .NET is built on something called IL code or Intermediate Language code. The code that you write is converted into unique identifiers that used to find functions, strings, etc in a giant look up table. You can find this table in the .NET header, it&#39;s called the Metadata Table. This is good to know if you decide to one day do .NET JIT function hooking or IL code modification, but for this challenge you&#39;ll need to identify when something is changed. Luckily Dnspy as a nice feature to help with this.</p>
<h2 is-upgraded>Anti-Tampering</h2>
<p>The init function is making sure that functions <code>a, b, c, d</code> haven&#39;t been tampered with. Instead of using the names of the function it uses the Method Identifier to determine which function bodies to verify. It will also swap function <code>a</code> with function <code>b</code> and function <code>c</code> with function <code>d</code>.</p>
<h2 is-upgraded>IL Code modification</h2>
<p>The same init function also calls a function to <code>CalculateStack</code>. If you follow this function down to <code>IdentifyLocals-&gt;IncrementStack</code> functions, you&#39;ll find that the function h body had been modified to swap function f with function g. </p>
<p>If you right click on the h function in Dnspy you can view the method body in a hex editor. This will help determine what bytes are actually being modified. Luckily Dnspy already converts function identifiers in to hex, which is easy to spot in the hex editor.</p>
<p class="image-container"><img style="width: 461.00px" src="../flareon6_2019/img/399d95c45c921cb7.png"></p>
<p>It will covert function 6000013 (f) -&gt; 6000014 (g)</p>
<p class="image-container"><img style="width: 516.00px" src="../flareon6_2019/img/e83831bf11a48cdd.png"></p>
<p>It will change the integer values in function g</p>
<p class="image-container"><img style="width: 485.00px" src="../flareon6_2019/img/5a8dc4c9300b507c.png"></p>
<p>The final product is then ...</p>
<pre><code>public static byte[] h(byte[] data)
                {
                        byte[] array = new byte[data.Length];
                        int num = 0;
                        for (int i = 0; i &lt; data.Length; i++)
                        {
                                int num2 = (int)Program.g(num++);
                                int num3 = (int)data[i];
                                num3 = (int)Program.e((byte)num3, (byte)num2);
                                num3 = (int)Program.b((byte)num3, 7);
                                int num4 = (int)Program.g(num++);
                                num3 = (int)Program.e((byte)num3, (byte)num4);
                                num3 = (int)Program.d((byte)num3, 3);
                                array[i] = (byte)num3;
                        }
                        return array;
                }</code></pre>
<h2 is-upgraded>Creating Inverse Functions</h2>
<p>The Flare team really likes you to go down rabbit holes. It may look like it&#39;s using some kind of RC4 but it&#39;s doing some simple math functions. These functions you can easily create inverses for. So functions b,d,e, h and i will need to be written as inverse functions meaning f(x) = y and g(y) = x. Excuse my shitty c# code.</p>
<p>Inverse h</p>
<pre><code>public static byte[] inverseh(byte[] data)
{
            byte[] array = new byte[data.Length];
        int A = 2* data.Length;
            int len = data.Length - 1;
            for (int i = data.Length-1; i &gt; -1; i--)
            {
                int B = (int)data[i];
                int Ap = A = A - 1;
                int App = A = A - 1;
                int X = (int)Program.g(Ap);
                int Y = (int)Program.g(App);
                B = (int)Program.inversed((byte)B, 3);
                int C = (int)Program.inversee((byte)B, (byte)X);
                int D = (int)Program.inverseb((byte)C, 7);
                int E = (int)Program.inversee((byte)D, (byte)Y);
                array[i] = (byte)E;
            }
            return array;
}</code></pre>
<p>Inverse B</p>
<pre><code>public static byte inverseb(byte b, int r)
        {
            for (int i = 0; i &lt; r; i++)
            {
                bool flag = (int)b % 2 == 0; // even
                if (flag)
                {
                    b = (byte)((int)b / 2);
                }
                else
                {
                    b = (byte)((int)b / 2 + 128);
                }
            }
            return b;
        }</code></pre>
<p>Inverse D</p>
<pre><code>public static byte id(byte b, int r)
        {
            for (int i = 0; i &lt; r; i++)
            {
                byte ob = b;
                if (b &lt; 128)
                {
                    b = (byte)((b * 2));
                }
                else
                {
                    b = (byte)(((b - 128) * 2) + 1);
                }
            }
            return b;
        }</code></pre>
<p>Inverse E</p>
<pre><code>public static byte inversee(byte b, byte k)
        {
            return (byte)(b ^ k);
        }</code></pre>
<p>Inverse I</p>
<pre><code>public static byte[] inversei(Bitmap bm, byte[] data)
{
            byte[] array = new byte[data.Length];
            int num = Program.j(103);
            int k = 0;
            for (int i = Program.j(103); i &lt; bm.Width; i++)
            {
                for (int j = Program.j(103); j &lt; bm.Height; j++)
                {
                    bool flag = num &gt; data.Length - Program.j(231);
                    if (flag)
                    {
                        break;
                    }
                    Color pixel = bm.GetPixel(i, j);
                    int red = (int)pixel.R;
                    int green = (int)pixel.G;
                    int blue = (int)pixel.B;
                    int out = red &amp; 7;
                    out = out | ((green &amp; 7) &lt;&lt; 3);
                    out = out | ((blue &amp; 3) &lt;&lt; 6);
                    num += Program.j(231);
                    array[k] = (byte)test;
                    k++;
                }
            }
            return array;
 }</code></pre>
<p>Besure to unit test your inverse functions. Finally plug in those images on the command line and watch them extract.</p>
<pre><code>Debug&gt;ConsoleApp1.exe image.bmp image.bmp out.bmp</code></pre>
<p>You get this image:</p>
<p class="image-container"><img style="width: 470.50px" src="../flareon6_2019/img/c47ef20372215c50.png"></p>
<p>Now let&#39;s do it again!</p>
<pre><code>Debug&gt;ConsoleApp1.exe out.bmp out.bmp final.bmp</code></pre>
<p>Nice.</p>
<p class="image-container"><img style="width: 238.00px" src="../flareon6_2019/img/711e04ef185436b2.png"></p>


      </google-codelab-step>

      <google-codelab-step label="Challenge 7 - Wopr" duration="0">
        <p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/6a0e3ae3bb536b00.png"></p>
<h2 is-upgraded>Summary</h2>
<p>This is a x32 Windows PE created by Pyinstaller exe that uses an annoying math problem to get launch codes.</p>
<h2 is-upgraded>Tools to use</h2>
<ul>
<li>PE Bear or CFF explorer</li>
<li>IDA</li>
<li><a href="https://github.com/rocky/python-uncompyle6" target="_blank">UnCompyle6</a></li>
<li><a href="https://sourceforge.net/projects/pyinstallerextractor/" target="_blank">PyInstaller Extractor</a></li>
<li><a href="https://github.com/Z3Prover/z3" target="_blank">Z3 Theorem Prover</a></li>
</ul>
<h2 is-upgraded>Challenge Text</h2>
<pre><code>Wopr
1
We used our own computer hacking skills to &#34;find&#34; this AI on a military supercomputer. It does strongly resemble the classic 1983 movie WarGames. Perhaps life imitates art? If you can find the launch codes for us, we&#39;ll let you pass to the next challenge. We promise not to start a thermonuclear war.
7Zip password: flare</code></pre>
<h2 is-upgraded>The War Games movie</h2>
<p>I hadn&#39;t watched War Games in a long time, so I decided to look up some clues and dialog. I saw that the launch code are all upper case letters and numbers: <code>DLG2209TVX.</code> My next assumption is that maybe these codes will look similar (all uppercase).</p>
<h2 is-upgraded>Identifying PyInstaller</h2>
<p>Looking at the disassembly there is a reference to the string &#34;_MEIPASS2&#34;. From my experience looking at py2exe and pyinstaller malware I was able to quickly identify that this string is related to pyinstaller. This string represents the offset of code that contains the python bytecode.</p>
<p class="image-container"><img style="width: 467.50px" src="../flareon6_2019/img/47915546b174ee0d.png"></p>
<h2 is-upgraded>Extracting Python Code</h2>
<p>Luckily there is a tool out there to extract the pyc or python compiled bytecode. I used PyInstaller Extractor.</p>
<pre><code>C:\Users\redteam\Desktop\7 - wopr&gt;C:\Python37\python.exe pyinstxtractor.py w
opr.exe
pyinstxtractor.py:86: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module&#39;s document
ation for alternative uses
  import imp
[*] Processing wopr.exe
[*] Pyinstaller version: 2.1+
[*] Python version: 37
[*] Length of package: 5068358 bytes
[*] Found 64 files in CArchive
[*] Beginning extraction...please standby
[+] Possible entry point: pyiboot01_bootstrap
[+] Possible entry point: pyiboot02_cleanup
[*] Found 135 files in PYZ archive
[*] Successfully extracted pyinstaller archive: wopr.exe</code></pre>
<p>Once you have the extracted folder, you&#39;ll notice that it is using Python37.dll. Going forward you will want to install this version to decompile. Now there are 2 entrypoints dumped by the extractor. The file <code>pyiboot02_cleanup</code> is the file to decompile.</p>
<h2 is-upgraded>Decompiling Python Code</h2>
<p>The header is stripped in <code>pyiboot02_cleanup</code>. Uncompyle6 requires that the correct header is present. Using python37 in Windows, compile a random python file so that you can copy it&#39;s pyc header. I noticed that Macos and Windows pyc headers are different. So whichever you used to compile Uncompyle6, and you should use the same OS and version of python37. The following command should to the trick.</p>
<pre><code>python37 -m compileall .</code></pre>
<p>This was my header:</p>
<pre><code>420D0D0A 00000000 4D5B635D 7B310000</code></pre>
<p>The final product of <code>pyiboot02_cleanup.pyc</code></p>
<pre><code>00000000: 420d 0d0a 0000 0000 4d5b 635d 7b31 0000  B.......M[c]{1..
00000010: e300 0000 0000 0000 0000 0000 0009 0000  ................
00000020: 0040 0000 0073 3c01 0000 6400 5a00 6401  .@...s&lt;...d.Z.d.
00000030: 6402 6c01 5a01 6401 6402 6c02 5a02 6401  d.l.Z.d.d.l.Z.d.
00000040: 6402 6c03 5a03 6401 6402 6c04 5a04 6401  d.l.Z.d.d.l.Z.d.
00000050: 6402 6c05 5a05 6401 6402 6c06 5a06 6401  d.l.Z.d.d.l.Z.d.
00000060: 6402 6c07 5a07 6401 6402 6c08 5a08 6401  d.l.Z.d.d.l.Z.d.
00000070: 6403 6c09 5400 650a 6404 8301 0100 6504  d.l.T.e.d.....e.
00000080: a00b 6405 6406 a102 5a0c 6900 6601 6407  ..d.d...Z.i.f.d.
00000090: 6408 8401 5a0d 6409 5a0e 640a 5a0f 650d  d...Z.d.Z.d.Z.e.</code></pre>
<p>Now to run uncompyle6</p>
<pre><code>uncompyle6 pyiboot02_cleanup.pyc</code></pre>
<h2 is-upgraded>Decrypting More Python Code</h2>
<p>Now that you have the decompiled python code, there is another layer of python code that needs to be decrypted. The &#34;_doc_&#34; which is the Shakespeare text at the beginning of the file contains the compressed and encrypted python code. You will need to extract out the _doc_ bytes from the original pyc file because the bytes existing between lines are actually the bytes used to RC4 decrypt (fire() function). </p>
<p>Next a key file is read from the folder that&#39;s obviously named &#34;key&#34;. A for loop that ranges from 0 to 256 while add 1 byte (<code>bytes([74])</code>) to the beginning of the key. It uses a try catch to handle any failures so it&#39;s hard to identify which one actually worked.</p>
<pre><code>for i in range(256):
    try:
        exec(lzma.decompress(fire(eye(__doc__.encode()), bytes([i]) + BOUNCE)))
    except Exception as e:
        pass</code></pre>
<p>The Flare team does a sneaky function switch by swapping <code>print</code> and <code>exec</code> functions. So when there is a successful decompression, it will continue to execute the decompressed python code without throwing an error.</p>
<h2 is-upgraded>Main Python Code</h2>
<p>You will still need x32dbg for this next part. In the function wrong, it acquires the handle to its own process in memory. </p>
<pre><code>trust = windll.kernel32.GetModuleHandleW(None)</code></pre>
<p>This means you will need to work with the process memory offsets as they exist post ntdll loading.</p>
<p class="image-container"><img style="width: 346.06px" src="../flareon6_2019/img/317f2b23d2a0c6aa.png"></p>
<p>You can dump and modify the python code so that it will take a bin file instead of actually getting a handle to the process memory.</p>
<pre><code>with open(&#34;wopr_01000000.bin&#34;, &#34;rb&#34;) as bin:
        wopr_addr = 0x1000000
        binbytes = bin.read()
        pbinbytes = c_char_p(binbytes)
        computer = string_at(pbinbytes, 1024)</code></pre>
<p>It will generate a md5 hash from processing this memory. This hash is xored with an integer array.</p>
<pre><code>xor = [212, 162, 242, 218, 101, 109, 50, 31, 125, 112, 249, 83, 55, 187, 131, 206]
h = [hash[i] ^ xor[i] for i in range(16)]
//output:
h = [115, 29, 32, 68, 106, 108, 89, 76, 21, 71, 78, 51, 75, 1, 55, 102]</code></pre>
<p>The xored hash is product is used to verify the launch codes (<code>b == h</code>) with the following:</p>
<pre><code>b[0] = x[2] ^ x[3] ^ x[4] ^ x[8] ^ x[11] ^ x[14]
b[1] = x[0] ^ x[1] ^ x[8] ^ x[11] ^ x[13] ^ x[14]
b[2] = x[0] ^ x[1] ^ x[2] ^ x[4] ^ x[5] ^ x[8] ^ x[9] ^ x[10] ^ x[13] ^ x[14] ^ x[15]
b[3] = x[5] ^ x[6] ^ x[8] ^ x[9] ^ x[10] ^ x[12] ^ x[15]
b[4] = x[1] ^ x[6] ^ x[7] ^ x[8] ^ x[12] ^ x[13] ^ x[14] ^ x[15]
b[5] = x[0] ^ x[4] ^ x[7] ^ x[8] ^ x[9] ^ x[10] ^ x[12] ^ x[13] ^ x[14] ^ x[15]
b[6] = x[1] ^ x[3] ^ x[7] ^ x[9] ^ x[10] ^ x[11] ^ x[12] ^ x[13] ^ x[15]
b[7] = x[0] ^ x[1] ^ x[2] ^ x[3] ^ x[4] ^ x[8] ^ x[10] ^ x[11] ^ x[14]
b[8] = x[1] ^ x[2] ^ x[3] ^ x[5] ^ x[9] ^ x[10] ^ x[11] ^ x[12]
b[9] = x[6] ^ x[7] ^ x[8] ^ x[10] ^ x[11] ^ x[12] ^ x[15]
b[10] = x[0] ^ x[3] ^ x[4] ^ x[7] ^ x[8] ^ x[10] ^ x[11] ^ x[12] ^ x[13] ^ x[14] ^ x[15]
b[11] = x[0] ^ x[2] ^ x[4] ^ x[6] ^ x[13]
b[12] = x[0] ^ x[3] ^ x[6] ^ x[7] ^ x[10] ^ x[12] ^ x[15]
b[13] = x[2] ^ x[3] ^ x[4] ^ x[5] ^ x[6] ^ x[7] ^ x[11] ^ x[12] ^ x[13] ^ x[14]
b[14] = x[1] ^ x[2] ^ x[3] ^ x[5] ^ x[7] ^ x[11] ^ x[13] ^ x[14] ^ x[15]
b[15] = x[1] ^ x[3] ^ x[5] ^ x[9] ^ x[10] ^ x[11] ^ x[13] ^ x[15]</code></pre>
<h2 is-upgraded>Using Z3 Theorem Solver</h2>
<p>I was too lazy to do solve the rest of this by hand, so my work CTF buddy suggested I used Z3. If you decide to install Z3 on a Mac you will need to compile the source code. Remember the launch codes are all uppercase letters and numbers. Here is my simple python z3 script that solved the puzzle.</p>
<pre><code>from z3 import *
solver = Solver()

x = [BitVec(&#39;input_%d&#39; % i, 8) for i in range(16)]
b = [115, 29, 32, 68, 106, 108, 89, 76, 21, 71, 78, 51, 75, 1, 55, 102]
#for i in range(0, len(e)):
#    solver.add(b[i] == e[i])

solver.add(b[0] == x[2] ^ x[3] ^ x[4] ^ x[8] ^ x[11] ^ x[14])
solver.add(b[1] == x[0] ^ x[1] ^ x[8] ^ x[11] ^ x[13] ^ x[14])
solver.add(b[2] == x[0] ^ x[1] ^ x[2] ^ x[4] ^ x[5] ^ x[8] ^ x[9] ^ x[10] ^ x[13] ^ x[14] ^ x[15])
solver.add(b[3] == x[5] ^ x[6] ^ x[8] ^ x[9] ^ x[10] ^ x[12] ^ x[15])
solver.add(b[4] == x[1] ^ x[6] ^ x[7] ^ x[8] ^ x[12] ^ x[13] ^ x[14] ^ x[15])
solver.add(b[5] == x[0] ^ x[4] ^ x[7] ^ x[8] ^ x[9] ^ x[10] ^ x[12] ^ x[13] ^ x[14] ^ x[15])
solver.add(b[6] == x[1] ^ x[3] ^ x[7] ^ x[9] ^ x[10] ^ x[11] ^ x[12] ^ x[13] ^ x[15])
solver.add(b[7] == x[0] ^ x[1] ^ x[2] ^ x[3] ^ x[4] ^ x[8] ^ x[10] ^ x[11] ^ x[14])
solver.add(b[8] == x[1] ^ x[2] ^ x[3] ^ x[5] ^ x[9] ^ x[10] ^ x[11] ^ x[12])
solver.add(b[9] == x[6] ^ x[7] ^ x[8] ^ x[10] ^ x[11] ^ x[12] ^ x[15])
solver.add(b[10] == x[0] ^ x[3] ^ x[4] ^ x[7] ^ x[8] ^ x[10] ^ x[11] ^ x[12] ^ x[13] ^ x[14] ^ x[15])
solver.add(b[11] == x[0] ^ x[2] ^ x[4] ^ x[6] ^ x[13])
solver.add(b[12] == x[0] ^ x[3] ^ x[6] ^ x[7] ^ x[10] ^ x[12] ^ x[15])
solver.add(b[13] == x[2] ^ x[3] ^ x[4] ^ x[5] ^ x[6] ^ x[7] ^ x[11] ^ x[12] ^ x[13] ^ x[14])
solver.add(b[14] == x[1] ^ x[2] ^ x[3] ^ x[5] ^ x[7] ^ x[11] ^ x[13] ^ x[14] ^ x[15])
solver.add(b[15] == x[1] ^ x[3] ^ x[5] ^ x[9] ^ x[10] ^ x[11] ^ x[13] ^ x[15])
print solver.check()
modl = solver.model()
print(modl)</code></pre>
<p>And finally the launch code:</p>
<pre><code>5C0G7TY2LWI2YXMB</code></pre>
<p class="image-container"><img style="width: 468.00px" src="../flareon6_2019/img/50fa90ca2aa39bce.gif"></p>


      </google-codelab-step>

      <google-codelab-step label="Challenge 8 - snake" duration="0">
        <p class="image-container"><img style="width: 334.00px" src="../flareon6_2019/img/ce5475835f0ee9af.png"></p>
<h2 is-upgraded>Summary</h2>
<p>An old NES game that has a simple patch to get to the flag scene.</p>
<h2 is-upgraded>Tools to use</h2>
<ul>
<li>fceux emulator</li>
<li>IDA (alternatives: Ghidra, Radare2)</li>
</ul>
<h2 is-upgraded>Challenge Text</h2>
<pre><code>snake
1
The Flare team is attempting to pivot to full-time twitch streaming video games instead of reverse engineering computer software all day. We wrote our own classic NES game to stream content that nobody else has seen and watch those subscribers flow in. It turned out to be too hard for us to beat so we gave up. See if you can beat it and capture the internet points that we failed to collect.</code></pre>
<h2 is-upgraded>NES resources</h2>
<p>Now I anticipated that there was going to be an NES challenge based on one of Nick Harbour&#39;s tweets. Luckily fceux emulator is all that you really needed for this challenge:</p>
<p class="image-container"><img style="width: 395.00px" src="../flareon6_2019/img/4b8f882bb6dfe43.png"></p>
<p>I didn&#39;t know anything about reversing NES games prior to this challenge. But any assembly language is just like any other assembly language and is easy to pick up. Looking up past NES CTF writeups and NESdev wiki was what I found most useful:</p>
<p><a href="http://wiki.nesdev.com/w/index.php/Tools" target="_blank">http://wiki.nesdev.com/w/index.php/Tools</a></p>
<p><a href="https://wiki.nesdev.com/w/index.php/PPU_nametables" target="_blank">https://wiki.nesdev.com/w/index.php/PPU_nametables</a></p>
<h2 is-upgraded>PPU Nametables</h2>
<p>So reading other CTF challenges gave me a clue to look at the PPU tables for any interesting information. I see that the tiled images of characters would probably be the flag. The next step is to find out how they are mapped and hardcoded in the NES code.</p>
<p class="image-container"><img style="width: 557.50px" src="../flareon6_2019/img/ee13a00fe651111.png"></p>
<p>I probably spent way too much time learning about NES reversing than actually solving the challenge. IDA mac doesn&#39;t really have a great NES plugin precompiled but as long as you use M6502 microprocessor when you load the bin file it should be fine. Here is what I used as an instruction resource <a href="http://obelisk.me.uk/6502/reference.html" target="_blank">http://obelisk.me.uk/6502/reference.html</a></p>
<p>In your disassembler be sure to rebase the image to 0xC000 and change the entrypoint to 0x10. At the end of the NES binary is where all the data is stored to display the tiles from the PPU tables. </p>
<p>When the snake is changing position, the assembly compares (CMP) the contents of the accumulator register at offset 0xC300. If you patch the branch instruction at offset 0xC302 to a JMP it will force the control flow to continue on to display the flag.</p>
<p class="image-container"><img style="width: 470.00px" src="../flareon6_2019/img/eecbe2c3e8dcfdc9.png"></p>
<p class="image-container"><img style="width: 365.50px" src="../flareon6_2019/img/b22bfa6f9b5afab5.png"></p>


      </google-codelab-step>

      <google-codelab-step label="Challenge 9 - reloadered" duration="0">
        <h2 is-upgraded>Summary</h2>
<p>A broken header x32 Windows PE that has some Rick-Rolling and Anti-Debugging fun.</p>
<h2 is-upgraded>Tools to use</h2>
<ul>
<li>IDA &amp; Ghidra (alternatives: Radare2)</li>
<li><a href="https://github.com/hasherezade/pe-bear-releases/releases" target="_blank">PE Bear</a> (alternatives: CFF explorer, PE studio)</li>
</ul>
<h2 is-upgraded>Challenge Text</h2>
<pre><code>reloadered
1
This is a simple challenge, enter the password, receive the key. I hear that it caused problems when trying to analyze it with ghidra. Remember that valid flare-on flags will always end with @flare-on.com
7zip password: flare</code></pre>
<h2 is-upgraded>Identifying the Problem</h2>
<p>Luckily the challenge text gave a really good hint as to what was broken about it. Typically disassemblers fail when there is an unexpected value being processed such as addresses being processed as an integer rather than an unsigned integer. I had guessed right off the bat that Ghidra was having a header parser issue and I was right.</p>
<p>The ghidra log was throwing this error. <img style="width: 624.00px" src="../flareon6_2019/img/488f99f8fa8d1a1d.png"></p>
<p>I went to go check the source code at the link below. And it was improperly handling the header base addressing. <a href="https://github.com/NationalSecurityAgency/ghidra/blob/5e593cb4ae18903b053ac4c84664ee3c632bd95f/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java#L313" target="_blank">https://github.com/NationalSecurityAgency/ghidra/blob/5e593cb4ae18903b053ac4c84664ee3c632bd95f/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/PeLoader.java#L313</a></p>
<pre><code>AddressRange brddRange =
                        new AddressRangeImpl(space.getAddress(originalImageBase + brdd.getVirtualAddress()),
                                space.getAddress(originalImageBase + brdd.getVirtualAddress() + brdd.getSize()));</code></pre>
<p>Luckily IDA doesn&#39;t have this same problem but you can always change the base image to a normal address like 0x400000.</p>
<p class="image-container"><img style="width: 215.62px" src="../flareon6_2019/img/d5a6c047b9e2927b.png"></p>
<h2 is-upgraded>Some Rick-Rolling</h2>
<p>When you use a debugger it takes you down a path that seems way too simple to be the solution. A simple if statement that you can easily do by hand and the key. </p>
<pre><code>if ((((((iVar3 == 0xb) &amp;&amp; (pcVar2[1] == &#39;o&#39;)) &amp;&amp; (((int)pcVar2[2] &amp; 0xfffffffU) == 0x54)) &amp;&amp;
     ((pcVar2[10] == &#39;G&#39; &amp;&amp; ((byte)~pcVar2[7] == 0xad)))) &amp;&amp;
    (((byte)(pcVar2[4] ^ pcVar2[3]) == 0x41 &amp;&amp;
     (((int)*pcVar2 * 3 - 0xf6U &lt; 2 &amp;&amp; ((int)pcVar2[8] * 0xc800 - 0x520800U &lt; 3)))))) &amp;&amp;
   ((pcVar2[6] == &#39;e&#39; &amp;&amp; (((pcVar2[5] &amp; 1U) == 0 &amp;&amp; (pcVar2[9] == &#39;n&#39;)))))) {
  uVar4 = 0;</code></pre>
<p>Obviously it presents you with a fake flag.</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/1423e45591540770.png"></p>
<h2 is-upgraded>Some Anti-Debugging</h2>
<p>If you throw the binary in a Hex editor there is a dead give away of where executable code might be placed. All the 0x90 nops are highly suspicious.</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/20c9e8248515a990.png"></p>
<p>Before main is even called, there is bootstrap code that sets up crt libs and arguments. At offset 0x1A4A is a call to <code>___scrt_is_nonwritable_in_current_image</code>. You will want to stepover this function or modify the branch at 0x1A52 to continue to the call to esi at 0x1A62 and step into. This is where the 0x90 nops are filled in with new code.</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/84ddee6ea6aa086e.png"></p>
<p>Add another breakpoint at offset 0x15AD to get past the performance time checks.</p>
<p>I was able to extract out the bytes that were placed in that section and just patched the binary at offset 0x6D0 so that I could view it casually in IDA and Ghidra.</p>
<h2 is-upgraded>The Actual Solution</h2>
<p>The following code is actually what is decrypting the key:</p>
<pre><code>_Buf = (char *)calloc(0xe,1);
                /* Call print */
FUN_004016a0(&#34;Enter key: &#34;,uVar15);
_File = (FILE *)__acrt_iob_func(0);
fgets(_Buf,0xe,_File);
_Buf[0xd] = 0;
cVar2 = *_Buf;
iVar8 = 0;
cVar3 = cVar2;
while (cVar3 != 0) {
  iVar8 = iVar8 + 1;
  cVar3 = _Buf[iVar8];
}
if (_Buf[iVar8 + -1] == &#39;\n&#39;) {
  iVar8 = 0;
  while (cVar2 != 0) {
    iVar8 = iVar8 + 1;
    cVar2 = _Buf[iVar8];
  }
  _Buf[iVar8 + -1] = 0;
}
uVar11 = 0;
cVar2 = *_Buf;
while (cVar2 != 0) {
  uVar11 = uVar11 + 1;
  cVar2 = _Buf[uVar11];
}
uVar6 = 0;
do {
  uVar9 = uVar6;
  abStack280[uVar9] = _Buf[uVar9 % uVar11] ^ *(byte *)((int)&amp;local_160 + uVar9);
  uVar6 = uVar9 + 1;
} while (uVar9 + 1 &lt; 0x35);
abStack280[uVar9] = 0;
if (uVar9 + 1 &lt; 0x100) {
  abStack280[uVar9 + 1] = 0;
  _Buf = strstr((char *)abStack280,&#34;@flare-on.com&#34;);
  if (_Buf == (char *)0x0) {
    FUN_004016a0(&#34;\nERROR: Wrong key!\n&#34;,uVar16);
    (*_DAT_000130a4)(0);
  }
  FUN_004016a0(&#34;Here is your prize:\n\n\t%s\n&#34;,0xe8);
  (*_DAT_000130a4)(0);
}</code></pre>
<p>The hint here is the 0x35 which gives away the length of a hardcoded value. Apart of the code that was placed in the 0x90 nop section contains the byte array that is being used in the sequence:</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/1843b7ac571454be.png"></p>
<p>The final value is:</p>
<pre><code>001DFDF0  7A 17 08 34 17 31 3B 25 5B 18 2E 3A 15 56 0E 11  z..4.1;%[..:.V..
001DFE00  3E 0D 11 3B 24 21 31 06 3C 26 7C 3C 0D 24 16 3A  &gt;..;$!1.&lt;&amp;|&lt;.$.:
001DFE10  14 79 01 3A 18 5A 58 73 2E 09 00 16 00 49 22 01  .y.:.ZXs.....I&#34;.
001DFE20  40 08 0A 14 00</code></pre>
<p>It&#39;s then easy to determine the decoder key with the simple Xor:</p>
<pre><code>33 48 65 61 64 65 64 4d 6f 6e 6B 65 79 -&gt; 3HeadedMonkey</code></pre>
<p>Here is the solution:</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/ce1e1c858e2531ce.png"></p>


      </google-codelab-step>

      <google-codelab-step label="Challenge 10 - Mugatu" duration="0">
        <p class="image-container"><img style="width: 592.50px" src="../flareon6_2019/img/73c426a1188e562.png"></p>
<h2 is-upgraded>Summary</h2>
<p>A Windows exe based on ransomware based on the Movie Zoolander. So hot right now. I actually used Ghidra the most on this challenge.</p>
<h2 is-upgraded>Tools to use</h2>
<ul>
<li><a href="https://x64dbg.com/" target="_blank">X32dbg</a> (alternatives: Ollydbg, Windbg, Immunity)</li>
<li>IDA &amp; Ghidra (alternatives: Radare2)</li>
<li><a href="https://github.com/hasherezade/pe-bear-releases/releases" target="_blank">PE Bear</a> (alternatives: CFF explorer, PE studio)</li>
</ul>
<h2 is-upgraded>Challenge Text</h2>
<pre><code>Mugatu
1
Hello,
I&#39;m working an incident response case for Derek Zoolander. He clicked a link and was infected with MugatuWare! As a result, his new headshot compilation GIF was encrypted. To secure an upcoming runway show, Derek needs this GIF decrypted; however, he refuses to pay the ransom. We received an additional encrypted GIF from an anonymous informant. The informant told us the GIF should help in our decryption efforts, but we were unable to figure it out. We&#39;re reaching out to you, our best malware analyst, in hopes that you can reverse engineer this malware and decrypt Derek&#39;s GIF.
I&#39;ve included a directory full of files containing:
MugatuWare malware
Ransom note (GIFtToDerek.txt)
Encrypted headshot GIF (best.gif.Mugatu)
Encrypted informant GIF (the_key_to_success_0000.gif.Mugatu)
Thanks, Roy
7zip password: flare</code></pre>
<h2 is-upgraded>Components of Ransomware</h2>
<p>Typically ransomware does a few tricks for anti-analysis and layered execution (hide shit in memory). Ransomware will also will create a ransom note, display a ransom note image to the user, and rename encrypted files.</p>
<h2 is-upgraded>Anti-Analysis</h2>
<p>One of the anti-analysis techniques is jumbling the IAT. The correct Windows API will resolve dynamically. You can choose to fix up the IAT or just continue to debug and fix up along the way. Luckily x32dbg will populate the right Windows API during runtime.</p>
<p>I&#39;ve summarized the functions that I chose to focus on:</p>
<p>1) 0x1cda WinMain</p>
<p>2) 0x1dad HTTP request to handle some twitter data, which you can patch to skip over. Nop out the branch at 0x1DB6:</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/695d3100cb0367f3.png"></p>
<p>3) 0x166e Load Images from Resources</p>
<p>4) 0x1491 Call Virtual Protect and Run DLL entrypoint function</p>
<p>5) 0x1447 Get function offset from DLL exported function</p>
<p>6) @0x1e29 CreateThread pointing to the DLL exported function 0x1724</p>
<h2 is-upgraded>Derelicte.dll</h2>
<p>In function 0x1491, a dll is loaded in memory but is fairly easy to carve out. Like the parent exe, the IAT of this dll is also jumbled so it&#39;s helpful to write down all the Windows API called dynamically.</p>
<p>Function 0x1229 recursively traverses the filesystem looking for folder <code>really, ridiculously good looking gifs</code>.</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/9fe9e6fa21ccba89.png"></p>
<p>It also dumps the ransom note in that same folder.</p>
<p class="image-container"><img style="width: 432.28px" src="../flareon6_2019/img/e3c88ea543999131.png"></p>
<p>A few functions deep, the encrypt function is being called dynamically. It&#39;s highly suspicious when malware uses CreateFileMapping to do file manipulation in memory.  And the first 4 bytes of this string is used as a part of the key to encrypt the files.</p>
<pre><code>00000000  54 4f 44 44 44 44 44 44 44 44 44 44 44 44 44 44  |TODDDDDDDDDDDDDD|
00000010  44 44 44 44 72 65 61 6c 6c 79 2c 20 72 65 61 6c  |DDDDreally, real|
00000020  6c 79 2c 20 72 65 61 6c 6c 79 2c 20 72 69 64 69  |ly, really, ridi|
00000030  63 75 6c 6f 75 73 6c 79 20 67 6f 6f 64 20 6c 6f  |culously good lo|
00000040  6f 6b 69 6e 67 20 67 69 66 73                    |oking gifs|</code></pre>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/5a9698dec9d73763.png"></p>
<p>Finally the encrypt function at 0x16b9:</p>
<pre><code>void ENCRYPT(int twentyhex,uint *chari,int TODD)

{
  uint keyi;
  uint chararray;
  uint ivar;
  uint charrout;

  charrout = *chari;
  chararray = chari[1];
  ivar = 0;
  do {
    keyi = (uint)*(byte *)((ivar &amp; 3) + TODD) + ivar;
    ivar = ivar + 0x9e3779b9;
    charrout = charrout + ((chararray &lt;&lt; 4 ^ chararray &gt;&gt; 5) + chararray ^ keyi);
    chararray = chararray +
                ((charrout * 0x10 ^ charrout &gt;&gt; 5) + charrout ^
                (uint)*(byte *)((ivar &gt;&gt; 0xb &amp; 3) + TODD) + ivar);
    twentyhex = twentyhex + -1;
  } while (twentyhex != 0);
  *chari = charrout;
  chari[1] = chararray;
  return;
}</code></pre>
<h2 is-upgraded>The Decrypt Function</h2>
<p>I used this cute little image as a unit test. Just place a gif in the <code>really, ridiculously good looking gifs</code> folder so that you can verify your encrypt algorithm. It helps verify your decryption function.</p>
<p class="image-container"><img style="width: 215.50px" src="../flareon6_2019/img/1c09df2a78f2aace.gif"></p>
<p>Here is my decrypt function in python:</p>
<pre><code>def decrypt(data, filename, key):
    output = []
    looplen = len(data) / 8
    i = 0
    for n in range(looplen):
        num = data[i:i+4]
        num2 = data[i+4:i+8]
        intA = unpack(&#34;I&#34;, num)[0]
        intB = unpack(&#34;I&#34;, num2)[0]

        storeA = intA
        storeB = intB
        ivarloop = 0x20
        for x in range(0x20):
            ivar = 0
            for x in range(ivarloop):
                ivar = (ivar - 0x61C88647) &amp; 0xFFFFFFFF
            keyi = key[ivar &amp; 3]
            keyi = keyi + ivar
            temp = storeA
            temp2 = temp
            temp2 = (temp &gt;&gt; 5) &amp; 0xFFFFFFFF
            temp3 = (temp &lt;&lt; 4) &amp; 0xFFFFFFFF
            temp2 = temp2 ^ temp3
            ivar2 = ivar &gt;&gt; 0xB
            temp = (temp2 + temp) &amp; 0xFFFFFFFF
            keyi2 = key[ivar2 &amp; 3]
            keyi2 = (keyi2 + ivar) &amp; 0xFFFFFFFF
            temp3 = temp ^ keyi2
            storeB = (storeB - temp3) &amp; 0xFFFFFFFF
            ivar = 0
            for x in range(ivarloop-1):
                ivar = (ivar - 0x61C88647) &amp; 0xFFFFFFFF
            keyi = key[ivar &amp; 3]
            intBlow = (storeB &lt;&lt; 4) &amp; 0xFFFFFFFF
            intBhigh = (storeB &gt;&gt; 5) &amp; 0xFFFFFFFF
            keyi = keyi + ivar
            temp = intBlow ^ intBhigh
            ivar = (ivar + 0x61C88647) &amp; 0xFFFFFFFF
            temp = (storeB + temp) &amp; 0xFFFFFFFF
            temp = (temp ^ keyi) &amp; 0xFFFFFFFF
            temp = (storeA - temp) &amp; 0xFFFFFFFF
            storeA = temp
            ivarloop -=1
        finalA = pack(&#34;I&#34;, storeA)
        finalB = pack(&#34;I&#34;, storeB)
        for a in finalA:
            output.append(a)
        for a in finalB:
            output.append(a)
        i+=8
    if i &lt; len(data):
        for a in data[i:]:
            output.append(a)
    with open(filename + &#34;.dec.gif&#34;, &#34;wb&#34;) as test:
        for o in output:
            test.write(o)</code></pre>
<p>Now the biggest hint that the <code>TODD</code> string gave is that the key is only 4 bytes long. Sometimes real ransomware will put hints into the encrypted filename. So the encrypted test image has this <code>0000</code> in the filename. Turns out this was the key in as in bytes: <code>0x00,0x00,0x00,0x00</code>.</p>
<p>the_key_to_success_0000.gif.Mugatu</p>
<p class="image-container"><img style="width: 252.50px" src="../flareon6_2019/img/ac0a5555d94708bf.gif"></p>
<p>The Flare team was nice enough to give you a hint for the final key in the best.gif image. Where <code>0x31</code> is the first byte in 4 byte array. From here on out you simple just need to bruteforce the last 3 bytes.</p>
<pre><code>SOLUTION = [49, 115, 53, 177]</code></pre>
<p>best.gif.Mugatu</p>
<p class="image-container"><img style="width: 480.00px" src="../flareon6_2019/img/8751cf2fd4b11e0b.gif"></p>


      </google-codelab-step>

      <google-codelab-step label="Challenge 11 - vv_max" duration="0">
        <h2 is-upgraded><img style="width: 596.00px" src="../flareon6_2019/img/bd1d23d810004be3.png"></h2>
<h2 is-upgraded>Summary</h2>
<p>Another esoteric language Windows x64 exe that uses AVX2 registers and instructions. For this challenge I used rust lang to help handle large integers.</p>
<h2 is-upgraded>Tools to use</h2>
<ul>
<li><a href="https://x64dbg.com/" target="_blank">X64dbg</a> (alternatives: Ollydbg, Windbg, Immunity)</li>
<li>IDA (alternatives: Ghidra, Radare2)</li>
<li><a href="https://github.com/hasherezade/pe-bear-releases/releases" target="_blank">PE Bear</a> (alternatives: CFF explorer, PE studio)</li>
</ul>
<h2 is-upgraded>Challenge Text</h2>
<pre><code>vv_max
1
Hey, at least its not subleq.
7zip password: flare</code></pre>
<h2 is-upgraded>Identifying the Problem</h2>
<p>This was actually one of my favorite challenges this year. I remember doing the subleq challenge from flareon4 so I knew what to expect for this challenge. It&#39;s a simple x64 windows PE program that uses a blob of bytes as the intermediate language for the instructions. The only issue I had was finding the right language to code this up. Rust lang works really well with handling register-like math operations and it also had a nice library called <a href="https://docs.rs/crate/bigint/4.2.0" target="_blank">bigint</a> which made it easy to work with large integers.</p>
<p>The program sets up the memory space storing the instruction blob and generating a vtable that handles all the instruction AVX2 instructions.<img style="width: 624.00px" src="../flareon6_2019/img/d1bcbc17075b01a1.png"></p>
<p>Simple vtable:</p>
<pre><code>000000000021EF40  00 00 00 00 00 00 00 00 B0 17 E2 3F 01 00 00 00  ........°.â?....
000000000021EF50  00 23 E2 3F 01 00 00 00 E0 21 E2 3F 01 00 00 00  .#â?....à!â?....
000000000021EF60  30 30 E2 3F 01 00 00 00 40 27 E2 3F 01 00 00 00  00â?....@&#39;â?....
000000000021EF70  D0 1D E2 3F 01 00 00 00 30 26 E2 3F 01 00 00 00  Ð.â?....0&amp;â?....
000000000021EF80  B0 1C E2 3F 01 00 00 00 10 2F E2 3F 01 00 00 00  °.â?...../â?....
000000000021EF90  50 19 E2 3F 01 00 00 00 B0 2B E2 3F 01 00 00 00  P.â?....°+â?....
000000000021EFA0  70 1A E2 3F 01 00 00 00 D0 2C E2 3F 01 00 00 00  p.â?....Ð,â?....
000000000021EFB0  90 1B E2 3F 01 00 00 00 F0 2D E2 3F 01 00 00 00  ..â?....ð-â?....
000000000021EFC0  E0 24 E2 3F 01 00 00 00 20 24 E2 3F 01 00 00 00  à$â?.... $â?....
000000000021EFD0  10 20 E2 3F 01 00 00 00 80 29 E2 3F 01 00 00 00  . â?.....)â?....
000000000021EFE0  D0 20 E2 3F 01 00 00 00 90 2A E2 3F 01 00 00 00  Ð â?.....*â?....
000000000021EFF0  60 28 E2 3F 01 00 00 00 F0 1E E2 3F 01 00 00 00  `(â?....ð.â?....
000000000021F000  00 26 E2 3F 01 00 00 00 00 00 00 00 00 00 00 00  .&amp;â?............ </code></pre>
<p>These instructions use a set of 32 byte arrays as ways to store values. I used colors to help me visualize the locations :) :</p>
<img style="width: 596.00px" src="../flareon6_2019/img/ColorBytes.PNG">
<p>I was too lazy to code up every line so I just carved out the blob instructions to be processed as bytes in rust. Keep in mind is that all math operations have to convert the bytes for little endian.</p>
<p>Program.bin:</p>
<pre><code>00000000: 0011 0041 4243 4441 4243 4441 0000 0000  ...ABCDABCDA....
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 0000 0011 012f 2f2f 2f2f 2f2f 2f2f 2f2f  .....///////////
00000030: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////
00000040: 2f2f 2f2f 2f11 0315 1111 1111 1111 1111  /////...........
00000050: 1113 1a1b 1b1b 1a15 1111 1111 1111 1111  ................
00000060: 1113 1a1b 1b1b 1a11 0410 1001 0204 0804  ................
00000070: 0810 1010 1010 1010 1010 1001 0204 0804  ................
00000080: 0810 1010 1010 1010 1011 0500 1013 04bf  ................
00000090: bfb9 b900 0000 0000 0000 0000 1013 04bf  ................
000000a0: bfb9 b900 0000 0000 0000 0011 062f 2f2f  .............///
000000b0: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////
000000c0: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f11 0a40  /////////////..@
000000d0: 0140 0140 0140 0140 0140 0140 0140 0140  .@.@.@.@.@.@.@.@
000000e0: 0140 0140 0140 0140 0140 0140 0140 0111  .@.@.@.@.@.@.@..
000000f0: 0b00 1001 0000 1001 0000 1001 0000 1001  ................
00000100: 0000 1001 0000 1001 0000 1001 0000 1001  ................
00000110: 0011 0c02 0100 0605 040a 0908 0e0d 0cff  ................
00000120: ffff ff02 0100 0605 040a 0908 0e0d 0cff  ................
00000130: ffff ff11 0d00 0000 0001 0000 0002 0000  ................
00000140: 0004 0000 0005 0000 0006 0000 00ff ffff  ................
00000150: ffff ffff ff11 10ff ffff ffff ffff ffff  ................
00000160: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000170: ffff ffff ffff ff11 1119 cde0 5bab d983  ............[...
00000180: 1f8c 6805 9b7f 520e 513a f54f a572 f36e  ..h...R.Q:.O.r.n
00000190: 3c85 ae67 bb67 e609 6a11 12d5 5e1c aba4  &lt;..g.g..j...^...
000001a0: 823f 92f1 11f1 595b c256 39a5 dbb5 e9cf  .?....Y[.V9.....
000001b0: fbc0 b591 4437 7198 2f8a 4211 1304 0000  ....D7q./.B.....
000001c0: 0005 0000 0006 0000 0007 0000 0000 0000  ................
000001d0: 0001 0000 0002 0000 0003 0000 0011 1400  ................
000001e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001f0: 0000 0000 0000 0000 0000 0000 0000 0011  ................
00000200: 1501 0000 0001 0000 0001 0000 0001 0000  ................
00000210: 0001 0000 0001 0000 0001 0000 0001 0000  ................
00000220: 0011 1602 0000 0002 0000 0002 0000 0002  ................
00000230: 0000 0002 0000 0002 0000 0002 0000 0002  ................
00000240: 0000 0011 1703 0000 0003 0000 0003 0000  ................
00000250: 0003 0000 0003 0000 0003 0000 0003 0000  ................
00000260: 0003 0000 0011 1804 0000 0004 0000 0004  ................
00000270: 0000 0004 0000 0004 0000 0004 0000 0004  ................
00000280: 0000 0004 0000 0011 1905 0000 0005 0000  ................
00000290: 0005 0000 0005 0000 0005 0000 0005 0000  ................
000002a0: 0005 0000 0005 0000 0011 1a06 0000 0006  ................
000002b0: 0000 0006 0000 0006 0000 0006 0000 0006  ................
000002c0: 0000 0006 0000 0006 0000 0011 1b07 0000  ................
000002d0: 0007 0000 0007 0000 0007 0000 0007 0000  ................
000002e0: 0007 0000 0007 0000 0007 0000 0015 1400  ................
000002f0: 1415 1500 1515 1600 1615 1700 1715 1800  ................
00000300: 1815 1900 1915 1a00 1a15 1b00 1b12 0701  ................
00000310: 0403 1c14 1503 1c1c 1603 1c1c 1703 1c1c  ................
00000320: 1803 1c1c 1903 1c1c 1a03 1c1c 1b05 0707  ................
00000330: 0613 1d11 0712 1e11 1904 0f1d 1e16 0801  ................
00000340: 0613 1d11 1512 1e11 0b04 1d1d 1e03 0f0f  ................
00000350: 1d16 0801 0613 1d11 1a12 1e11 0604 1d1d  ................
00000360: 1e03 0f0f 1d03 1d14 1005 1e14 1203 1d1d  ................
00000370: 1e0b 0f1d 0f0b 140f 0007 0708 0703 1d14  ................
00000380: 1c15 111d 1314 0705 0713 1d11 0712 1e11  ................
00000390: 1904 0f1d 1e13 1d11 1512 1e11 0b04 1d1d  ................
000003a0: 1e03 0f0f 1d13 1d11 1a12 1e11 0604 1d1d  ................
000003b0: 1e03 0f0f 1d07 0201 0703 1d15 1005 1e15  ................
000003c0: 1203 1d1d 1e0b 0f1d 0f0b 150f 0003 1d15  ................
000003d0: 1c15 111d 1303 1414 1513 1d11 0712 1e11  ................
000003e0: 1904 0f1d 1e13 1d11 1512 1e11 0b04 1d1d  ................
000003f0: 1e03 0f0f 1d13 1d11 1a12 1e11 0604 1d1d  ................
00000400: 1e03 0f0f 1d01 0702 0a03 1d16 1005 1e16  ................
00000410: 1203 1d1d 1e0b 0f1d 0f0b 160f 0003 1d16  ................
00000420: 1c15 111d 1303 1414 1613 1d11 0712 1e11  ................
00000430: 1904 0f1d 1e13 1d11 1512 1e11 0b04 1d1d  ................
00000440: 1e03 0f0f 1d13 1d11 1a12 1e11 0604 1d1d  ................
00000450: 1e03 0f0f 1d02 0207 0b03 1d17 1005 1e17  ................
00000460: 1203 1d1d 1e0b 0f1d 0f0b 170f 0003 1d17  ................
00000470: 1c15 111d 1303 1414 1713 1d11 0712 1e11  ................
00000480: 1904 0f1d 1e13 1d11 1512 1e11 0b04 1d1d  ................
00000490: 1e03 0f0f 1d13 1d11 1a12 1e11 0604 1d1d  ................
000004a0: 1e03 0f0f 1d03 1d18 1005 1e18 1203 1d1d  ................
000004b0: 1e0b 0f1d 0f0b 180f 0003 1d18 1c15 111d  ................
000004c0: 1303 1414 1813 1d11 0712 1e11 1904 0f1d  ................
000004d0: 1e13 1d11 1512 1e11 0b04 1d1d 1e03 0f0f  ................
000004e0: 1d13 1d11 1a12 1e11 0604 1d1d 1e03 0f0f  ................
000004f0: 1d03 1d19 1005 1e19 1203 1d1d 1e0b 0f1d  ................
00000500: 0f0b 190f 0003 1d19 1c15 111d 1303 1414  ................
00000510: 1914 0202 0c13 1d11 0712 1e11 1904 0f1d  ................
00000520: 1e13 1d11 1512 1e11 0b04 1d1d 1e03 0f0f  ................
00000530: 1d13 1d11 1a12 1e11 0604 1d1d 1e03 0f0f  ................
00000540: 1d03 1d1a 1005 1e1a 1203 1d1d 1e0b 0f1d  ................
00000550: 0f0b 1a0f 0003 1d1a 1c15 111d 1303 1414  ................
00000560: 1a13 1d11 0712 1e11 1904 0f1d 1e13 1d11  ................
00000570: 1512 1e11 0b04 1d1d 1e03 0f0f 1d13 1d11  ................
00000580: 1a12 1e11 0604 1d1d 1e03 0f0f 1d15 0202  ................
00000590: 0d03 1d1b 1005 1e1b 1203 1d1d 1e0b 0f1d  ................
000005a0: 0f0b 1b0f 0003 1d1b 1c15 111d 1303 1414  ................
000005b0: 1b11 13ff ffff ffff ffff ffff ffff ffff  ................
000005c0: ffff ffff ffff ffff ffff ff00 0000 0000  ................
000005d0: 0000 0005 1414 1311 1f22 1e1b 4b2d 1705  .........&#34;..K-..
000005e0: 0c15 590e 7823 2633 2e10 074f 7318 3658  ..Y.x#&amp;3...Os.6X
000005f0: 0b29 0f5c 3a0c 6276 21ff                 .).\:.bv!.</code></pre>
<p>The next function 0x1830 will process the program binary data be looping through the bytes. Every instruction has a set size for immediate values and math operations. One of the final instructions will compare one of the command line arguments post processed to <code>0x1ea1f3b229c845e81a861c08a82aa70a615ed201acb27070</code>. The other command line argument is actually given to you in the final function: <code>FLARE2019</code>.</p>
<h2 is-upgraded>Coding up the program</h2>
<p>Here is some quick rust code for processing the program:</p>
<pre><code>extern crate bigint;
extern crate byteorder;
use bigint::U256;
use byteorder::{BigEndian, ReadBytesExt, LittleEndian};
use std::mem::transmute;
use std::fs::File;
use std::io::Read;

fn shrd_2980(val: U256, count : u32) -&gt; U256 {
    let mut valvec: [u8; 32] = [0; 32];
    val.to_big_endian(&amp;mut valvec);
    let mut out_vec: Vec&lt;u8&gt; = vec![];
    for mut chunk in valvec.chunks(4) {
        let mut result: u32 = chunk.read_u32::&lt;BigEndian&gt;().unwrap();
        result = result &gt;&gt; count;
        let dst: [u8; 4] = unsafe { transmute(result.to_be()) };
        out_vec.extend(dst.to_vec().iter().cloned())
    }
    let output: U256 = out_vec.as_slice().into();
    return output;
}

fn shld_20d0(val: U256, count : u32) -&gt; U256 {
    let mut valvec: [u8; 32] = [0; 32];
    val.to_big_endian(&amp;mut valvec);
    let mut out_vec: Vec&lt;u8&gt; = vec![];
    for mut chunk in valvec.chunks(4) {
        let mut result: u32 = chunk.read_u32::&lt;BigEndian&gt;().unwrap();
        result = result &lt;&lt; count;
        let dst: [u8; 4] = unsafe { transmute(result.to_be()) };
        out_vec.extend(dst.to_vec().iter().cloned());
    }
    let output: U256 = out_vec.as_slice().into();
    return output;
}

fn addb_1cb0(val: U256, val2: U256) -&gt;  U256 {
    let mut valvec: [u8; 32] = [0; 32];
    val.to_big_endian(&amp;mut valvec);
    let mut valvec2: [u8; 32] = [0; 32];
    val2.to_big_endian(&amp;mut valvec2);
    let mut out_vec: Vec&lt;u8&gt; = vec![0; 32];
    let mut i = 0;
    while i &lt; valvec.len(){
        let int1 = valvec[i] as i8;
        let int2 = valvec2[i] as i8;
        let (r, _) = int1.overflowing_add(int2);
        let result = r as u8;
        out_vec[i] = result;
        i+=1;
    }
    let output: U256 = out_vec.as_slice().into();
    return output;
}

fn addd_1a70(val: U256, val2: U256) -&gt;  U256 {
    let mut valvec: [u8; 32] = [0; 32];
    val.to_big_endian(&amp;mut valvec);
    let mut valvec2: [u8; 32] = [0; 32];
    val2.to_big_endian(&amp;mut valvec2);
    let mut out_vec: Vec&lt;u8&gt; = vec![];
    let mut i = 0;
    while i &lt; valvec.len(){
        let mut chunk = &amp;valvec[i..i+4];
        let mut chunk2 = &amp;valvec2[i..i+4];
        let int1: i32 = chunk.read_i32::&lt;BigEndian&gt;().unwrap();
        let int2: i32 = chunk2.read_i32::&lt;BigEndian&gt;().unwrap();
        let (r, _) = int1.overflowing_add(int2);
        let result =  r as u32;
        let dst: [u8; 4] = unsafe { transmute(result.to_be()) };
        out_vec.extend(dst.to_vec().iter().cloned());
        i+=4;
    }
    let output: U256 = out_vec.as_slice().into();
    return output;
}

fn vpmaddubsw_2300(val: U256, val2: U256) -&gt;  U256 {
    let mut valvec: [u8; 32] = [0; 32];
    val.to_big_endian(&amp;mut valvec);
    let mut valvec2: [u8; 32] = [0; 32];
    val2.to_big_endian(&amp;mut valvec2);
    let mut out_vec: Vec&lt;u8&gt; = vec![];
    let mut i = 0;
    while i &lt; valvec.len(){
        let  int1 = valvec[i] as u16;
        let  int2 = valvec2[i] as u16;
        let  int3 = valvec[i+1] as u16;
        let  int4 = valvec2[i+1] as u16;
        let (r1, _) = int1.overflowing_mul(int2);
        let (r2, _) = int3.overflowing_mul(int4);
        let (result,_) = r1.overflowing_add(r2);
        let dst: [u8; 2] = unsafe { transmute(result.to_be()) };
        out_vec.extend(dst.to_vec().iter().cloned());
        i+=2;
    }
    let output: U256 = out_vec.as_slice().into();
    return output;
}
fn vpmaddwd_21e0(val: U256, val2: U256) -&gt;  U256 {
    let mut valvec: [u8; 32] = [0; 32];
    val.to_big_endian(&amp;mut valvec);
    let mut valvec2: [u8; 32] = [0; 32];
    val2.to_big_endian(&amp;mut valvec2);
    let mut out_vec: Vec&lt;u8&gt; = vec![];
    let mut i = 0;
    while i &lt; valvec.len(){
        let mut int1 = &amp;valvec[i..i+2];
        let  num1: u32 = int1.read_u16::&lt;BigEndian&gt;().unwrap() as u32;
        let mut int2 = &amp;valvec2[i..i+2];
        let  num2: u32 = int2.read_u16::&lt;BigEndian&gt;().unwrap() as u32;
        let mut int3 = &amp;valvec[i+2..i+2+2];
        let  num3: u32 = int3.read_u16::&lt;BigEndian&gt;().unwrap() as u32;
        let mut int4 = &amp;valvec2[i+2..i+2+2];
        let  num4: u32 = int4.read_u16::&lt;BigEndian&gt;().unwrap() as u32;
        let (r1, _) = num1.overflowing_mul(num2);
        let (r2, _) = num3.overflowing_mul(num4);
        let (result,_) = r1.overflowing_add(r2);
        let dst: [u8; 4] = unsafe { transmute(result.to_be()) };
        out_vec.extend(dst.to_vec().iter().cloned());
        i+=4;
    }
    let output: U256 = out_vec.as_slice().into();
    return output;

}

fn shuffle_2a90(val: U256, val2: U256) -&gt;  U256 {
    let mut a: [u8; 32] = [0; 32];
    val.to_little_endian(&amp;mut a);
    let mut b: [u8; 32] = [0; 32];
    val2.to_little_endian(&amp;mut b);
    let mut r = [0; 32];
    for i in 0..16 {
        // if the most significant bit of b is set,
        // then the destination byte is set to 0.
        if b[i] &amp; 0x80 == 0u8 {
            r[i] = a[(b[i] % 16) as usize];
        }
        if b[i + 16] &amp; 0x80 == 0u8 {
            r[i + 16] = a[(b[i + 16] % 16 + 16) as usize];
        }
    }
    let output: U256 = U256::from_little_endian(&amp;r);
    return output;
}

fn xor_3030(val: U256, val2: U256) -&gt;  U256 {
    let result = val ^ val2;
    return result;
}

fn or_2740( val: U256, val2: U256) -&gt;  U256 {
    let result = val | val2;
    return result;
}
fn and_1dd0( val: U256, val2: U256) -&gt;  U256 {
    let result = val &amp; val2;
    return result;
}

fn permute(val: U256, val2: U256) -&gt; (U256, bool) {
    let mut valvec: [u8; 32] = [0; 32];
    let mut valvec2: [u8; 32] = [0; 32];
    val.to_little_endian(&amp;mut valvec);
    val2.to_little_endian(&amp;mut valvec2);
    let mut temp: Vec&lt;u8&gt; = vec![];
    let test: U256 = 0.into();
    let mut i = 0;
    while i &lt; valvec.len(){
        if val2 == test{
            let out: Vec&lt;&amp;[u8]&gt; = valvec.chunks(4).collect();
            temp.extend(out[0].iter().cloned());
        } else {
            let mut chunk = &amp;valvec2[i..i+4];
            let  result: u32 = chunk.read_u32::&lt;LittleEndian&gt;().unwrap();
            let out: Vec&lt;&amp;[u8]&gt; = valvec.chunks(4).collect();
            if result as usize &lt;= out.len(){
                temp.extend(out[result as usize].iter().cloned());
            } else {
                let newval: [u8; 4] = unsafe { transmute(0u32.to_be()) };
                temp.extend(newval.iter().cloned());
            }
        }
        i+=4;
    }
    let  result: U256 = U256::from_little_endian(temp.as_slice());
    return (result, true);
}

fn run(testval:u32, s: &amp;Vec&lt;u8&gt;) -&gt; bool {
    let newval: [u8; 4] = unsafe { transmute(testval.to_be()) };
    let arg1: [u8; 32] = [
    0x46,0x4c,0x41,0x52,0x45,0x32,0x30,0x31,
    0x39,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00];

    let mut arg2: [u8; 32] = [
    0x5d,0x48,0x43,0x79,0x72,0x41,0x48,0x53,
    0x58,0x6D,0x45,0x4b,0x70,0x79,0x71,0x18,
    0x45,0x42,0x79,0x47,0x47,0x75,0x68,0x46,
    0x79,0x43,0x6d,0x79,0x38,0x36,0x45,0x65];
    let  solution2: U256 = U256::from_little_endian(&amp;arg2);
    let solution: U256 = U256::from_little_endian(&amp;arg1);

    let mut memory: Vec&lt;U256&gt; = vec![ 0.into(); 32];
    let mut k = 0;
    for _i in 0..0x1000{
        let b = s[k];
        match b {
            0 =&gt;  {
                println!(&#34;create memory&#34;);
                k+= 1 },
            1 =&gt;  {
                println!(&#34;muladdu 2300  {}= {} * {}&#34;, s[k+1], s[k+2], s[k+3]);
                memory[s[k+1] as usize] = vpmaddubsw_2300(memory[s[k+2] as usize], memory[s[k+3] as usize]);
                k+= 4},
            2 =&gt;  {
                println!(&#34;muladd 21E0   {}= {} * {}&#34;, s[k+1], s[k+2], s[k+3]);
                memory[s[k+1] as usize] = vpmaddwd_21e0(memory[s[k+2] as usize], memory[s[k+3] as usize]);
                k+= 4},
            3 =&gt;  {
                println!(&#34;xor 0303      {}= {} ^ {}&#34;, s[k+1], s[k+2], s[k+3]);
                memory[s[k+1] as usize] = xor_3030(memory[s[k+2] as usize], memory[s[k+3] as usize]);
                k+= 4},
            4 =&gt;  {
                println!(&#34;or 2407       {}= {} | {}&#34;, s[k+1], s[k+2], s[k+3]);
                memory[s[k+1] as usize] = or_2740(memory[s[k+2] as usize], memory[s[k+3] as usize]);
                k+= 4},
            5 =&gt;  {
                println!(&#34;and 1DD0      {}= {} &amp; {}&#34;, s[k+1], s[k+2], s[k+3]);
                memory[s[k+1] as usize] = and_1dd0(memory[s[k+2] as usize], memory[s[k+3] as usize]);
                k+= 4},
            6 =&gt;  {
                println!(&#34;xor 2630&#34;);
                k+=4},
            7 =&gt;  {
                println!(&#34;addb 1CB0     {}= {} + {}&#34;, s[k+1], s[k+2], s[k+3]);
                memory[s[k+1] as usize] = addb_1cb0(memory[s[k+2] as usize], memory[s[k+3] as usize]);
                k+= 4},
            8 =&gt;  {
                println!(&#34;subb 2F10     {}= {} - {}&#34;, s[k+1], s[k+2], s[k+3]);
                k+= 4},
            9 =&gt;  {
                println!(&#34;addw 1950     {}= {} + {}&#34;, s[k+1], s[k+2], s[k+3]);
                k+= 4},
            10 =&gt; {
                println!(&#34;subw 2BB0     {}= {} - {}&#34;, s[k+1], s[k+2], s[k+3]);
                k+= 4},
            11 =&gt; {
                println!(&#34;addd 1A70     {}= {} + {}&#34;, s[k+1], s[k+2], s[k+3]);
                memory[s[k+1] as usize] = addd_1a70(memory[s[k+2] as usize], memory[s[k+3] as usize]);
                k+= 4},
            12 =&gt; {
                println!(&#34;subd 2CD0     {}= {} - {}&#34;, s[k+1], s[k+2], s[k+3]);
                k+= 4},
            13 =&gt; {
                println!(&#34;addq     {}= {} - {}&#34;, s[k+1], s[k+2], s[k+3]);
                k+= 4},
            14 =&gt; {
                println!(&#34;subq     {}= {} - {}&#34;, s[k+1], s[k+2], s[k+3]);
                k+= 4},
            15 =&gt; {
                println!(&#34;mulq     {}= {} - {}&#34;, s[k+1], s[k+2], s[k+3]);
                k+= 4},
            16 =&gt; {},
            17 =&gt; {
                let mut store: U256 = U256::from_little_endian(&amp;s[k+2..k+34]);

                if s[k+1] == 0{
                    memory[s[k+1] as usize] = solution;
                } else if s[k+1] == 1{
                    memory[s[k+1] as usize] = solution2;
                }else {
                    memory[s[k+1] as usize] = store;
                }
                println!(&#34;store 2010 {}={:x}&#34;, s[k+1], memory[s[k+1] as usize]);
                k+= 34},
            18 =&gt; {
                println!(&#34;shr 2980      {}= mem {} &gt;&gt; 0x{:x}&#34;, s[k+1], s[k+2], s[k+3]);
                memory[s[k+1] as usize] = shrd_2980(memory[s[k+2] as usize], s[k+3] as u32);
                k+= 4},
            19 =&gt; {
                println!(&#34;shl 20D0      {}= mem {} &lt;&lt; 0x{:x}&#34;, s[k+1], s[k+2], s[k+3]);
                memory[s[k+1] as usize] = shld_20d0(memory[s[k+2] as usize], s[k+3] as u32);
                k+= 4},
            20 =&gt; {
                println!(&#34;shuffle 2A90  {}= {} &lt;- {}&#34;, s[k+1], s[k+2], s[k+3]);
                memory[s[k+1] as usize] = shuffle_2a90(memory[s[k+2] as usize], memory[s[k+3] as usize]);
                k+= 4},
            21 =&gt; {
                println!(&#34;permute 2860  {}= {} &lt;- {}&#34;, s[k+1], s[k+2], s[k+3]);
                let (result, success) = permute(memory[s[k+2] as usize], memory[s[k+3] as usize]);
                if success {
                    memory[s[k+1] as usize] = result;
                }
                k+= 4},
            22 =&gt; {
                let mut _iseq = false;
                if memory[s[k+2] as usize] == memory[s[k+3] as usize]{
                    _iseq = true;
                    let istrue: [u8; 32] = [0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
                    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
                    0xff,0xff,0xff,0xff,0xff];
                    let mut trueval: U256 = istrue.into();
                    memory[s[k+1] as usize] = trueval;

                } else {
                    let mut falseval: U256 = 0.into();
                    memory[s[k+1] as usize] = falseval;
                }
                println!(&#34;cmpeqb        {} = {} == {} {}&#34;, s[k+1], s[k+2], s[k+3], _iseq);
                k+= 4},
            23 =&gt; {k+= 1},
            0xff =&gt; {
                println!(&#34;=END=&#34;);
                break},
            _=&gt; println!(&#34;?&#34;),
        }
        if k &gt; s.len(){
            break;
        }
    }
    let finalval: U256 = memory[2];
    let finalval2: U256 = memory[20];
    let mut b: [u8; 32] = [0; 32];
    finalval.to_little_endian(&amp;mut b);
    let mut a: [u8; 32] = [0; 32];
    finalval2.to_little_endian(&amp;mut a);
    println!(&#34;{:x} {:x}&#34;, finalval, finalval2);
    if b[0] == a[0] &amp;&amp;  a[1] == b[1] &amp;&amp; a[2] == b[2] &amp;&amp; a[3] == b[3]{
        println!(&#34;{:x}&#34;, finalval2);
        println!(&#34;{:x}&#34;, finalval);
        return true;
    }
    return false;
}

fn main() {
    let mut file = File::open(&#34;./program.bin&#34;).unwrap();
    let mut s: Vec&lt;u8&gt; = Vec::with_capacity(file.metadata().unwrap().len() as usize);
    file.read_to_end(&amp;mut s).unwrap();
    run(0u32, &amp;s);
}</code></pre>
<p>The final comparison value is only modified a few about 5 times in the whole program:</p>
<pre><code>0x1ea1f3b229c845e81a861c08a82aa70a615ed201acb27070 -&gt;
0x1ea1f3b2 29c845e81a861c0800000000a82aa70a615ed201acb27070 -&gt;
0xf3a11e00c829b2001ae84500081c8600a72aa8005e610a00ac01d2007070b2 -&gt;
0x11e0F3a09b20C82084501ae0c8600810aa80a72010a05e601d20ac000b20707 -&gt;
0x1e043a3c3226023205212e0606320102282a32290a0426171207002b3202071c</code></pre>
<p>Then the last instructions input values can be either done by hand or brute forced. In this case I just brute forced the input</p>
<pre><code>let mut lookup: [u8; 32] = [
    0x00,0x10,0x13,0x04,0xBF,0xBF,0xB9,0xB9,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x10,0x13,0x04,0xBF,0xBF,0xB9,0xB9,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00];
    let mut b: [u8; 32] = [0; 32];
    result5.to_little_endian(&amp;mut b);
    let mut k: usize = 0;
    while k &lt; b.len(){
        for i in 0u32..0xFFFFFu32 {
            let (res, overflow) = i.overflowing_shr(0x4);
            let num1 = res &amp; 0x2f2f;

            let mut B: u8 = ((i &gt;&gt; 8) &amp; 0xFF) as u8;
            let mut A: u8 = (i &amp; 0xFF) as u8;

            let B1: u8 = ((num1 &gt;&gt; 8) &amp; 0xFF) as u8;
            let A1: u8 = (num1 &amp; 0xFF) as u8;

            if A1 &lt; 32 &amp;&amp; B1 &lt; 32{
                let (aa, _) = b[k].overflowing_sub(lookup[A1 as usize]);
                let (bb, _) = b[k+1].overflowing_sub(lookup[B1 as usize]);
                if aa == A &amp;&amp; bb == B{
                    println!(&#34;{:x}-&gt;{:x} {:x}-&gt;{:x}&#34;,b[k],A,b[k+1],B);
                }
            } else {
                continue;
            }
        }
        k+=1;
    }</code></pre>
<p>The final flag is decrypted with a simple xor based on the input value you provided.</p>
<p>cHCyrAHSXmEKpyqoCByGGuhFyCmy86Ee</p>
<p>Example output:</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/e8988a498279369d.png"></p>


      </google-codelab-step>

      <google-codelab-step label="Challenge 12 - help" duration="0">
        <p class="image-container"><img style="width: 614.00px" src="../flareon6_2019/img/7fab15172aa0df7a.png"></p>
<h2 is-upgraded>Summary</h2>
<p>A x64 Windows memory dump that contains a few kernel drivers and userland Dlls. Looks like a plugin style RAT. I used Rust lang again to help decrypt the data. This challenge had many parts to it. Hopefully I can cover all the major items.</p>
<h2 is-upgraded>Tools to use</h2>
<ul>
<li><a href="https://github.com/volatilityfoundation/volatility" target="_blank">Volatility</a></li>
<li><a href="https://github.com/hasherezade/pe-bear-releases/releases" target="_blank">PE Bear</a> (alternatives: CFF explorer, PE studio)</li>
<li>IDA (alternatives: Ghidra, Radare2)</li>
<li>Windbg</li>
<li>Hex Editor</li>
<li>Wireshark</li>
</ul>
<h2 is-upgraded>Challenge Text</h2>
<pre><code>help
1
You&#39;re my only hope FLARE-On player! One of our developers was hacked and we&#39;re not sure what they took. We managed to set up a packet capture on the network once we found out but they were definitely already on the system. I think whatever they installed must be buggy - it looks like they crashed our developer box. We saved off the dump file but I can&#39;t make heads or tails of it - PLEASE HELP!!!!!!
7Zip password: flare</code></pre>
<h2 is-upgraded>Crash Dump Clue</h2>
<p>If you open the crash dump in windbg it will show the exception address. This is the address where you should start looking in volatility. Below is a snippet.</p>
<pre><code>FAULTING_IP:
+0
fffffa80`03f9c621 64a10000000050648925 mov eax,dword ptr fs:[2589645000000000h]

EXCEPTION_RECORD:  fffff88007c6b958 -- (.exr 0xfffff88007c6b958)
ExceptionAddress: fffffa8003f9c621
   ExceptionCode: c0000005 (Access violation)
  ExceptionFlags: 00000000
NumberParameters: 2
   Parameter[0]: 0000000000000000
   Parameter[1]: ffffffffffffffff
Attempt to read from address ffffffffffffffff

CONTEXT:  fffff88007c6b1b0 -- (.cxr 0xfffff88007c6b1b0)
rax=fffffa8003f9c610 rbx=fffffa80040c65c0 rcx=fffffa80036ab5c0
rdx=fffff880033c8138 rsi=fffffa80018cc090 rdi=0000000000000001
rip=fffffa8003f9c621 rsp=fffff88007c6bb98 rbp=0000000007c6bbb0
 r8=fffff80002c3f400  r9=0000000000000000 r10=0000000000000000
r11=fffff80002c3ae80 r12=fffffa80036ab5c0 r13=fffff880033bdcc0
r14=0000000000000000 r15=fffff80000b94080
iopl=0         nv up ei ng nz na po nc
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00010286
fffffa80`03f9c621 64a10000000050648925 mov eax,dword ptr fs:[2589645000000000h] fs:0053:25896450`00000000=????????
Resetting default scope</code></pre>
<h2 is-upgraded>Using Volatility</h2>
<p>So 0xfffffa800XXXXXXX is where interesting stuff is happening which means this could be a kernel driver. Now to run all the driver related commands (<a href="https://github.com/volatilityfoundation/volatility/wiki/Command-Reference" target="_blank">command references</a>):</p>
<pre><code>vol.py -f help.dmp --profile=Win7SP1x64 driverscan</code></pre>
<p>Output:</p>
<pre><code>Offset(P)              #Ptr     #Hnd Start                            Size Service Key          Name         Driver Name
------------------ -------- -------- ------------------ ------------------ -------------------- ------------ -----------
0x000000007d48d9a0        4        1 0xfffffa80042d0000             0xf000                      FLARE...ed_0
0x000000007ff87db0        3        0 0xfffff88000e9c000            0xa4000 Wdf01000             Wdf01000     \Driver\Wdf01000</code></pre>
<p>Modules:</p>
<pre><code>vol.py -f help.dmp --profile=Win7SP1x64 drivermodule</code></pre>
<p>Output:</p>
<pre><code>Module                               Driver                   Alt. Name                Service Key
------------------------------------ ------------------------ ------------------------ -----------
fileinfo.sys                         FileInfo                 FileInfo                 \FileSystem\FileInfo
UNKNOWN                              FLARE_Loaded_0 </code></pre>
<p>Module Scan:</p>
<pre><code>vol.py -f help.dmp --profile=Win7SP1x64 modscan</code></pre>
<p>Output:</p>
<pre><code>Offset(P)          Name                 Base                             Size File
------------------ -------------------- ------------------ ------------------ ----
0x000000007d48ff30 man.sys              0xfffff880033bc000             0xf000 \??\C:\Users\FLARE ON 2019\Desktop\man.sys</code></pre>
<h2 is-upgraded>Extracting the Drivers</h2>
<p>Now to extract man.sys and FLARE_Loaded_0.</p>
<p>vol.py -f help.dmp --profile=Win7SP1x64 moddump -r man.sys --dump-dir ../tmp/</p>
<p>Output Error:</p>
<p>Module Base        Module Name          Result</p>
<p>------------------ -------------------- ------</p>
<p>0xfffff880033bc000 man.sys              Error: e_magic 0000 is not a valid DOS signature.</p>
<p>So it seemed that this driver did not have a header. I didn&#39;t feel like extracting out the driver from the help.dmp file manually so I decided to modify volatility code instead. I traced the error to the function <code>get_nt_header</code>. It was just looking for a simple &#34;MZ&#34; to verify that it was an executable. So I just added this code to the function:</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/ce88cec06195aeb0.png"></p>
<p>The next step was to rebuild the header of the driver, you can find the driver in memory or just copy an existing header and eyeball the section offsets. IDA should help you determine the driver entry function using it&#39;s FLIRT signatures.</p>
<h2 is-upgraded>TCP Stream Filter Driver</h2>
<p>I was familiar with writing file system filter drivers but not TCP stream filter drivers. I used the <a href="https://github.com/microsoft/Windows-driver-samples/blob/master/network/trans/stmedit/sys/StreamEdit.c" target="_blank">microsoft sample drivers</a> as reference so that I could follow along.</p>
<p>Basically the callout classify function handles the stream buffers.</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/e813f144b0455589.png"></p>
<p>Stream encoding:</p>
<pre><code>let mut key7777 = vec![0x4a, 0x1f, 0x4b, 0x1c, 0xb0, 0xd8, 0x25, 0xc7];
while i &lt; encoded.len(){
        let blah = encoded[i] ^ key7777[i%8] &amp; 0xFF;
        out[i] = blah;
        i+=1;
    }</code></pre>
<p>It was easy to validate the decryption by looking for pool allocation tags in the help.dmp. I just used a hex editor to search for those.</p>
<pre><code>VirtualAddress = ExAllocatePoolWithTag((POOL_TYPE)0x200, *(_QWORD *)(argData + 0x60), &#39;RALF&#39;);</code></pre>
<p>The keys for each port were then easy to find in memory since the port preceded the key in hex:</p>
<p>Key for port 6666</p>
<pre><code>D5 69 94 FA 25 EC DF DA</code></pre>
<p class="image-container"><img style="width: 556.00px" src="../flareon6_2019/img/ccd35c862393c701.png"></p>
<p>Key for port 7777</p>
<pre><code>4a 1f 4b 1c b0 d8 25 c7</code></pre>
<p>Key for port 8888</p>
<pre><code>F7 8F 78 48 47 1A 44 9C</code></pre>
<h2 is-upgraded>Man.sys Driver</h2>
<p>This driver serves as the kernel agent. It basically handles all the commands delivered by the userland m.dll it loaded into svchost.exe. The biggest hint here was the validation it did for the PDB file. Every PDB file related had a similar path. You could then search for all the other dll files in the help.dmp file.</p>
<pre><code>e:\dropbox\dropbox\flareon_2019\code\cryptodll\objchk_win7_amd64\amd64\c.pdb</code></pre>
<h2 is-upgraded>Userland Agent Handler: m.dll </h2>
<p>I certainly got quite annoyed from decrypting all those RC4 encrypted strings. Luckily <a href="https://gchq.github.io/CyberChef/" target="_blank">cyberchef</a> had a nifty tool to convert hex into bytes and then process those bytes into RC4. All the major Windows APIs and C std functions were dynamically loaded and executed. It was more tedious to reveal all those strings.</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/bf99e7cf90ed9775.png"></p>
<h2 is-upgraded>VAD Trees</h2>
<p>The reason why this challenge took so long, is that I forgot all about non-contiguous memory and Virtual Address Descriptor (VAD) trees. Luckily volatility has a command to dump these sections. Then all you need to do is find the memory dumps from svchost.</p>
<pre><code>vol.py -f help.dmp --profile=Win7SP1x64 vaddump -D vads</code></pre>
<p>svchost.exe.7e2a4b30.0x0000000000d50000-0x0000000000d52fff.dmp</p>
<p>svchost.exe.7e2a4b30.0x0000000000d60000-0x0000000000d62fff.dmp</p>
<p>svchost.exe.7e2a4b30.0x0000000000d80000-0x0000000000d85fff.dmp</p>
<p>...</p>
<p>After grabbing those dlls from memory it was all downhill from there.</p>
<p>All related dll files:</p>
<table>
<tr><td colspan="1" rowspan="1"><p>Name</p>
</td><td colspan="1" rowspan="1"><p>Description</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>filedll</p>
</td><td colspan="1" rowspan="1"><p>Searches filesystem for target file with port 6666</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>screenshotdll</p>
</td><td colspan="1" rowspan="1"><p>Takes a screenshot with port 7777</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>keylogdll</p>
</td><td colspan="1" rowspan="1"><p>Monitors keys but ignores some special characters with port 8888</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>cryptodll</p>
</td><td colspan="1" rowspan="1"><p>Compresses with LZNT1 and encrypts with RC4 with the %Username%\x00 </p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>networkdll</p>
</td><td colspan="1" rowspan="1"><p>Sends network traffic</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>m.dll</p>
</td><td colspan="1" rowspan="1"><p>Main dll to handle commands from the C2 server with port 4444. Forwards commands to the main driver.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Shellcode Driver</p>
</td><td colspan="1" rowspan="1"><p>This is probably what caused the crash in the first place.</p>
</td></tr>
</table>
<h2 is-upgraded>Decrypting Traffic</h2>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/81321d6991718890.png"></p>
<p>Wireshark will allow you to dump TCP streams between 192.168.1.243 and 192.168.1.244. At first I wrote a simple PCAP parser program in rust because I originally thought every TCP packet was being modified instead of the stream. So I just ended dumping out all the streams by hand in wireshark which was no big deal.</p>
<p>First I started with decrypting the traffic on port 4444 which are the commands to the kernel agent. It was looking for a keepass kdb file. </p>
<pre><code>00000000: 1f01 0000 b5da 80d1 7484 fade ab58 321e  ........t....X2.
00000010: 0501 0000 433a 5c6b 6579 7061 7373 5c6b  ....C:\keypass\k
00000020: 6579 732e 6b64 6200 0000 0000 0000 0000  eys.kdb.........
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000050: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000080: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000100: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000110: 0000 0000 0000 0000 002d 9cc6 0000 00    .........-.....</code></pre>
<p>I looked up the header file for KeePass versions and I was able to carve out a KDB file from the help.dmp file. However, I wasn&#39;t sure at the time that this was the same KDB. (It actually was).</p>
<ul>
<li>KeePass 1.x KDB File (this one):<br><code>03 D9 A2 9A 65 FB 4B B5</code></li>
<li>KeePass 2.x KDBX File:<br><code>03 D9 A2 9A 67 FB 4B B5</code></li>
</ul>
<p>The next traffic I decrypted was on port 7777. Here are the decrypted screenshots I actually cared about:</p>
<p>I thought this search was quite funny:</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/72204ed4ef22ab4c.png"></p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/cb471e33ec5be44a.png"></p>
<p>At this point I was saddened that I had to find the master key from the keylogging output off of port 8888. So my next step was to decrypt the traffic for port 8888. The streams from the keylogger were using the LZNT1 and RC4 encryption from the crypto dll.</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/a090919e2b0d3a13.png"></p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/7b5df95280ad3fdf.png"></p>
<p>So I plugged in that key which I thought was the masterkey and realized that the length of the key in the screenshot did not match the length of the keylogger output. I had to revisit the keylogger dll to see what was going on.</p>
<p class="image-container"><img style="width: 400.50px" src="../flareon6_2019/img/e4f1c49c4826d4f5.png"></p>
<p>Turns out it was actually not using the shift keys for special characters, dropping any special characters like &#34;_&#34;, and only taking the lowercase version of the key.</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/d6d6b30f9022584e.png"></p>
<p>I did a simple search in help.dmp for &#34;th3_&#34; and was able to partially find the key:</p>
<p class="image-container"><img style="width: 624.00px" src="../flareon6_2019/img/d7292c79c8eadff6.png"></p>
<p>Master password was <code>Th!s_iS_th3_3Nd!!!</code></p>
<p>And the flag was <code>f0ll0w_th3_br34dcrumbs@flare-on.com</code></p>
<p>At this point I&#39;m so happy. Much relieved. My husband is glad I can stop talking about flareon6.</p>
<p class="image-container"><img style="width: 220.00px" src="../flareon6_2019/img/6cdf51bc83c89f86.gif"></p>


      </google-codelab-step>

      <google-codelab-step label="Final Thoughts" duration="0">
        <p>My two favorite challenges this year as 11 &amp; 12. I felt like the clue giving was very sophisticated. Compared to the last time I played (flareon4), I felt that this year was a bit easier. However, I&#39;m very thankful that the Flare Team gives multiple weeks to finish these challenges. I only had a few hours each weekend and some time in the work week evenings to actually work on these challenges.</p>
<p>Thank you Flare Team, I very much enjoyed this year. <img style="width: 624.00px" src="../flareon6_2019/img/f51ad84d1e3c7324.png"></p>


      </google-codelab-step>

  </google-codelab>

  <script src="../pkg/native-shim.js"></script>
  <script src="../pkg/custom-elements.min.js"></script>
  <script src="../pkg/prettify.js"></script>
  <script src="../pkg/codelab-elements.js"></script>

</body>
</html>
